{
  "hash": "ab70c17be5521b2910387e3ffee87bba",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Finite difference Methods for European Options\"\nsubtitle: \"EDP in finance\"\nauthor:\n  - name: Cheryl KOUADIO\n  - name: Marilene Kougoum\ncategories: [paper,m2mo,edp]\ndate: \"2026-01-14\"\njupyter: python3\n---\n\n\n\n\n\n# Introduction\n\nDans ce tp, nous √©tudion des sch√©mas aux diff√©rences finies pour l'√©quation de Black-Scholes pos√©e dans les variables primitives, apr√®s localisation dans un rectangle dans les variables temps-spot.\n\nCes sch√©mas nous permettront d'obtenir une approximation num√©rique de la fonction de prix d'un put europ√©en $v(t,s)$, avec $t \\in [0,T]$ et $s \\in [S_{min}, S_{max}]$. Cette fonction satisfait l'√©quation de Black-Scholes sur le domaine tronqu√© $\\Omega = [0,T] \\times [S_{min}, S_{max}]$ :\n\n$$\n\\begin{cases}\n\\frac{\\partial v}{\\partial t}\n+ \\frac{1}{2} \\sigma^2 s^2 \\frac{\\partial^2 v}{\\partial s^2}\n+ r s \\frac{\\partial v}{\\partial s}\n- r v = 0, \\quad (t,s) \\in \\Omega, \\\\\nv(T,s) = \\phi(s) = \\max(K - s, 0),\n\\quad s \\in [S_{\\min}, S_{\\max}], \\\\\nv(t,S_{\\min}) = K e^{-r(T - t)} - S_{\\min},\n\\quad t \\in (0,T), \\\\\nv(t,S_{\\max}) = 0,\n\\quad t \\in (0,T).\n\\end{cases}\n$$\n\nNous consid√©rons la grille discr√®te suivante : $h = \\frac{S_{max} - S_{min}}{J + 1}$ et $\\Delta t = \\frac{T}{N}$, avec $J$ et $N$ des entiers positifs, et :\n- $s_j = S_{min} + j h$, pour $j = 0, \\ldots, J + 1$,\n- $t_n = n \\Delta t$, pour $n = 0, \\ldots, N$.\n\nOn cherche une approximation $U_j^n \\approx v(t_n, s_j)$ pour $j = 1, \\ldots, J$ et $n = 0, \\ldots, N$.\n\nLes sch√©mas aux diff√©rences finies nous permettront de discr√©tiser l'√©quation de Black-Scholes du prix d'un put europ√©en sur cette grille.\nDans ce TP, nous consid√©rons divers $\\theta$-sch√©mas num√©riques pour ce probl√®me: Le sch√©ma d'Euler explicite, puis Euler implicite, et enfin de Crank-Nicolson.  On √©tudie l'erreur de consistance pour ces sch√©mas. Ces sch√©mas conduisent √† des relations de r√©currence dans $\\mathbb{R}^n$, chaque pas consistant √©ventuellement √† r√©soudre un syst√®me lin√©aire dans le cas des sch√©mas implicites.\n\nOn √©tudie enfin la convergence de ces $\\theta$-sch√©mas. On verra appara√Ætre la notion de stabilit√© conditionnelle (et de condition CFL) pour certains sch√©mas tels que le sch√©ma d'Euler Explicite, et la notion de stabilit√© inconditionnelle pour d'autres sch√©mas tels que le sch√©ma d'Euler Implicite ou de Crank-Nicolson.\n\n# M√©thodes num√©riques\n\n## Sch√©ma d'Euler explicite (EE)\n\nLe sch√©ma d'Euler explicite est un sch√©ma bas√© sur une discr√©tisation explicite en temps. La discr√©tisation de l'EDP est bas√©e sur des approximations centr√©es. D√®s lors, on approxime les d√©riv√©es partielles de la mani√®re suivante :\n\n$$\n\\begin{cases}\n\\frac{U_j^{n+1} - U_j^n}{\\Delta t} + \\frac{1}{2} \\sigma^2 s_j^2 \\frac{U_{j+1}^n - 2 U_j^n + U_{j-1}^n}{h^2} + r s_j \\frac{U_{j+1}^n - U_{j-1}^n}{2 h} - r U_j^n = 0, \\quad j = 1, \\ldots, J,\\quad n = 0, \\ldots, N-1. \\\\\nU_j^0 = \\phi(s_j), \\quad j = 1, \\ldots, J. \\\\\nU_0^n = K e^{-r(T - t_n)} - S_{min}, \\quad n = 0, \\ldots, N. \\\\\nU_{J+1}^n = 0, \\quad n = 0, \\ldots, N.\n\\end{cases}\n$$\n\nOn peut la r√©√©crire sous la forme matricielle afin d'extraire une solution num√©rique dite explicite :\nSous forme matricielle, le sch√©ma s'√©crit :\n\n$$\n\\begin{array}{l}\n\\frac{U^{n+1} - A U^n}{\\Delta t} +  A U^n + q(t_n) = 0, \\quad n = 0, \\ldots, N-1, \\\\\nU^0 = (\\phi(s_i))_{1 \\leq i \\leq J},\n\\end{array}\n$$\n\no√π\n\n-   $A$ est une matrice carr√©e tridiagonale de taille $J \\times J$.\n    En posant $\\alpha_j = \\frac{\\sigma^2}{2} \\frac{s_j^2}{h^2}$ et $\\beta_j = r \\frac{s_j}{2 h}$, les coefficients de la matrice $A$ sont donn√©s par :\n\n    $$\n    \\begin{cases}\n    A_{j,j-1} = -\\alpha_j + \\beta_j, \\quad j= 2, \\ldots, J, \\\\\n    A_{j,j} = 2\\alpha_j + r, \\quad j = 1, \\ldots, J, \\\\\n    A_{j,j+1} = -\\alpha_j - \\beta_j, \\quad j = 1, \\ldots, J.\n    \\end{cases}\n    $$\n\n-   $q(t_n)$ un vecteur de $\\mathbb{R}^J$ qui d√©pendent des param√®tres du mod√®le et de la discr√©tisation spatiale donn√© par :\n\n    $$\n    q_j(t_n) =\n    \\begin{cases}\n    (-\\alpha_1 + \\beta_1) U_0^n, \\quad j = 1, \\\\\n    0, \\quad j = 2, \\ldots, J-1, \\\\\n    (-\\alpha_J + \\beta_J) U_{J+1}^n, \\quad j = J.\n    \\end{cases}\n    $$\n\nDe fait, on obtient la relation de r√©currence explicite permettant de calculer $U^{n+1}$ en fonction de $U^n$ :\n\n$$\nU^{n+1} = A U^n - \\Delta t ( A U^n + q(t_n) ), \\quad n = 0, \\ldots, N-1,\n$$\n\n## Sch√©ma d'Euler implicite (EI)\nLe sch√©ma d'Euler implicite est un sch√©ma bas√© sur une discr√©tisation implicite en temps. La discr√©tisation de l'EDP est bas√©e sur des approximations centr√©es. D√®s lors, on approxime les d√©riv√©es partielles de la mani√®re suivante :\n\n$$\\begin{cases}\n\\frac{U_j^{n+1} - U_j^n}{\\Delta t} + \\frac{1}{2} \\sigma^2 s_j^2 \\mathbf{\\frac{U_{j+1}^{n+1} - 2 U_j^{n+1} + U_{j-1}^{n+1}}{h^2} + r s_j \\frac{U_{j+1}^{n+1} - U_{j-1}^{n+1}}{2 h} - r U_j^{n+1}} = 0, \\quad j = 1, \\ldots, J,\\quad n = 0, \\ldots, N-1. \\\\\nU_j^0 = \\phi(s_j), \\quad j = 1, \\ldots, J. \\\\  \nU_0^n = K e^{-r(T - t_n)} - S_{min}, \\quad n = 0, \\ldots, N. \\\\\nU_{J+1}^n = 0, \\quad n = 0, \\ldots, N.\n\\end{cases}\n$$\n\nDans ce cas, la relation de r√©currence s'√©crit sous la forme matricielle suivante :\n\n$$\n\\begin{array}{l}\n\\frac{U^{n+1} - A U^n}{\\Delta t} +  A U^{n+1} + q(t_{n+1}) = 0, \\quad n = 0, \\ldots, N-1, \\\\\nU^0 = (\\phi(s_i))_{1 \\leq i \\leq J},\n\\end{array}\n$$\n\no√π $A$ et $q(t_n)$ sont d√©finis comme pr√©c√©demment.\nOn obtient ainsi la relation de r√©currence implicite suivante :\n\n$$\n( I + \\Delta t A ) U^{n+1} = U^n - \\Delta t q(t_{n+1}), \\quad n = 0, \\ldots, N-1,\n$$\no√π $I$ est la matrice identit√© de taille $J \\times J$.  \n\n## Sch√©ma de Crank-Nicolson (CN)\nLe sch√©ma de Crank-Nicolson est un sch√©ma bas√© sur une discr√©tisation implicite en temps. La discr√©tisation de l'EDP est bas√©e sur des approximations centr√©es. D√®s lors, on approxime les d√©riv√©es partielles de la mani√®re suivante :\n\n$$\n\\begin{cases}\n\\frac{U_j^{n+1} - U_j^n}{\\Delta t} + \\frac{1}{2} \\left( - \\sigma^2 s_j^2 \\frac{U_{j+1}^{n+1} - 2 U_j^{n+1} + U_{j-1}^{n+1}}{h^2}  - r s_j \\frac{U_{j+1}^{n+1} - U_{j-1}^{n+1}}{2 h} + r U_j^{n+1} \\right. \\\\\n\\quad + \\frac{1}{2} \\left( - \\sigma^2 s_j^2 \\frac{U_{j+1}^n - 2 U_j^n + U_{j-1}^n}{h^2} - r s_j \\frac{U_{j+1}^n - U_{j-1}^n}{2 h} + r U_j^n \\right) = 0, \\quad j = 1, \\ldots, J,\\quad n = 0, \\ldots, N-1. \\\\\nU_j^0 = \\phi(s_j), \\quad j = 1, \\ldots, J. \\\\\nU_0^n = K e^{-r(T - t_n)} - S_{min}, \\quad n = 0, \\ldots, N. \\\\\nU_{J+1}^n = 0, \\quad n = 0, \\ldots, N.\n\\end{cases}\n$$\n\nLa relation de r√©currence s'√©crit sous la forme matricielle suivante :\n$$\n\\begin{array}{l}\n\\frac{U^{n+1} - A U^n}{\\Delta t} +  \\frac{1}{2} A ( U^{n+1} + U^n ) + \\frac{1}{2} ( q(t_{n+1}) + q(t_n) ) = 0, \\quad n = 0, \\ldots, N-1, \\\\\nU^0 = (\\phi(s_i))_{1 \\leq i \\leq J},\n\\end{array}\n$$\no√π $A$ et $q(t_n)$ sont d√©finis comme pr√©c√©demment.\nOn obtient ainsi la relation de r√©currence implicite suivante :\n$$\\left( I + \\frac{\\Delta t}{2} A \\right) U^{n+1} = \\left( I - \\frac{\\Delta t}{2} A \\right) U^n - \\frac{\\Delta t}{2} ( q(t_{n+1}) + q(t_n) ), \\quad n = 0, \\ldots, N-1,\n$$\no√π $I$ est la matrice identit√© de taille $J \\times J$.\n\n\n## Choix d'impl√©mentations\n\nPuisque les sch√©mas impl√©ment√©s partagent de nombreuses caract√©ristiques communes, nous d√©finissons une classe de base abstraite `SchemeBase` qui encapsule les param√®tres financiers, la grille discr√®te, les conditions initiales et aux limites, ainsi que la construction de la matrice $A$ et du vecteur $q(t)$. Les sch√©mas sp√©cifiques h√©riteront de cette classe de base et impl√©menteront la m√©thode `solve()` pour r√©soudre le sch√©ma num√©rique particulier.\n\nTrois classes filles seront ensuite d√©finies : `SchemeEE` pour le sch√©ma d'Euler explicite, `SchemeEI` pour le sch√©ma d'Euler implicite, et `SchemeCN` pour le sch√©ma de Crank-Nicolson. Chacune de ces classes impl√©mentera la m√©thode `solve()` en fonction de la nature explicite ou implicite du sch√©ma.\n\nLes codes sont retrouv√©s sur ce lien github [github](https://github.com/cheryl-kdio/EDP-M2MO/tree/main/TP1).\n\n::: {#daeb275a .cell execution_count=1}\n``` {.python .cell-code}\n# Package imports\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport numpy.linalg as lng\nfrom scipy.sparse import diags,eye\nfrom abc import ABC, abstractmethod\nimport scipy.stats as stats\nfrom scipy.sparse import csr_matrix as sparse\nfrom scipy.sparse.linalg import spsolve\nimport pandas as pd\nimport time\nfrom pprint import pprint\n```\n:::\n\n\n::: {#fa5c2a50 .cell execution_count=2}\n``` {.python .cell-code}\nclass SchemeBase(ABC):\n    \"\"\"\n    Classe de base pour les sch√©mas num√©riques de l'√©quation de Black-Scholes.\n    \"\"\"\n    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):\n        # Financial parameters\n        self.r = r\n        self.sigma = sigma\n        self.K = K\n        self.T = T\n\n        # Numerical parameters\n        self.N = N\n        self.J = J\n        self.Smin = Smin\n        self.Smax = Smax\n\n        # Grids\n        self.dt = T / N\n        self.h = (Smax - Smin) / (J + 1)\n        self.s = Smin + self.h * np.arange(1, J + 1)\n\n        # Operator\n        self.A, self.alpha, self.beta = self._build_matrix_A()\n\n    def phi(self, s):\n        \"\"\"\n        Condition initiale (payoff) pour un put europ√©en.\n        ùúô(s) = max(K - s, 0)\n        \"\"\"\n        return np.maximum(self.K - s, 0)\n\n    def uleft(self, t):\n        \"\"\"\n        Condition aux limites √† gauche pour un put europ√©en.\n        u( t, Smin ) = K * exp(-r * t) - S\n        \"\"\"\n        return self.K * np.exp(-self.r * t) - self.Smin\n\n    def uright(self, t):\n        \"\"\"\n        Condition aux limites √† droite pour un put europ√©en.\n        u( t, Smax ) = 0\n        \"\"\"\n        return 0.0\n\n    def _build_matrix_A(self):\n        \"\"\"\n        Matrice d'amplification A.\n        \"\"\"\n        alpha = 0.5 * self.sigma**2 * (self.s**2 / self.h**2)\n        beta  = self.r * self.s / (2 * self.h)\n\n        lower = -alpha[1:] + beta[1:]        # sous-diagonale\n        main  = 2 * alpha + self.r            # diagonale principale\n        upper = -alpha[:-1] - beta[:-1]       # sur-diagonale\n\n        A = diags(\n            diagonals=[lower, main, upper],\n            offsets=[-1, 0, 1],\n            shape=(self.J, self.J),\n            format=\"csr\"\n        )\n\n        return A, alpha, beta\n\n\n    def q(self, t):\n        \"\"\"\n        Vecteur des conditions aux limites.\n        \"\"\"\n        y = np.zeros(self.J)\n        y[0]  = (-self.alpha[0] + self.beta[0]) * self.uleft(t)\n        y[-1] = (-self.alpha[-1] - self.beta[-1]) * self.uright(t)\n        return y\n\n    def interpolate(self, Sval, U):\n        \"\"\"\n        Interpolation lin√©aire pour obtenir la valeur approxim√©e d'un put\n        en un point spot Sval donn√©.\n        \"\"\"\n        if Sval <= self.Smin:\n            return self.uleft(self.T)\n        elif Sval >= self.Smax:\n            return self.uright(self.T)\n        else:\n            return np.interp(Sval, self.s, U)\n\n    # Abstract method\n    @abstractmethod\n    def solve(self):\n        \"\"\"\n        M√©thode abstraite de r√©solution du sch√©ma num√©rique.\n        \"\"\"\n        raise NotImplementedError(\"M√©thode solve() √† impl√©menter dans la classe fille\")\n```\n:::\n\n\n::: {#803cce32 .cell execution_count=3}\n``` {.python .cell-code}\nclass SchemeEE(SchemeBase):\n    \"\"\"\n    Sch√©ma d'Euler explicite.\n    \"\"\"\n    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):\n        super().__init__(r, sigma, K, T, N, J, Smin, Smax)\n        self.scheme_name = \"Euler Explicite\"\n\n    def solve(self):\n        \"\"\"\n        R√©solution du sch√©ma d'Euler explicite.\n        \"\"\"\n        U = self.phi(self.s)\n\n        for n in range(self.N):\n            t = n * self.dt\n            U = U - self.dt * (self.A @ U + self.q(t))\n\n        return U,t\n```\n:::\n\n\n::: {#8a7401c9 .cell execution_count=4}\n``` {.python .cell-code}\nclass SchemeEI(SchemeBase):\n    \"\"\"\n    Sch√©ma d'Euler implicite.\n    \"\"\"\n    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):\n        super().__init__(r, sigma, K, T, N, J, Smin, Smax)\n        self.scheme_name = \"Euler Implicite\"\n\n    def solve(self):\n        U = self.phi(self.s)\n        I = eye(self.J, format=\"csr\")\n\n        for n in range(self.N):\n            t = n * self.dt\n            U = spsolve(I + self.dt * self.A, U - self.dt * self.q(t))\n\n        return U,t\n```\n:::\n\n\n::: {#5ae805c2 .cell execution_count=5}\n``` {.python .cell-code}\nclass SchemeCN(SchemeBase):\n    \"\"\"\n    Sch√©ma de Crank-Nicolson.\n    \"\"\"\n    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):\n        super().__init__(r, sigma, K, T, N, J, Smin, Smax)\n        self.scheme_name = \"Crank-Nicolson\"\n\n    def solve(self):\n        U = self.phi(self.s)\n        I = eye(self.J, format=\"csr\")\n        factor_minus = I - 0.5 * self.dt * self.A\n        factor_plus = I + 0.5 * self.dt * self.A\n\n        for n in range(self.N):\n            t = n * self.dt\n            U = spsolve(factor_plus, factor_minus@U - self.dt * self.q(t))\n        return U,t\n```\n:::\n\n\n# R√©sultats des sch√©mas num√©riques\n\n::: {#f5a9be83 .cell execution_count=6}\n``` {.python .cell-code}\nr_ = 0.1\nsigma_ = 0.2\nK_ = 100\nT_ = 1\nSmin_ = 0\nSmax_ = 200\nprint(\"Param√®tres financiers:\")\nprint(\"r=%.2f\" %r_, \"sigma=%.2f\" %sigma_, \"K=%.0f\" %K_, \"T=%.0f\" %T_)\n\n# Definition des param√®tres dans un dictionnaire\nparams = dict(\n    r=r_,\n    sigma=sigma_,\n    K=K_,\n    T=T_,\n    N=None, # Valeur √† d√©finir plus tard\n    J=None, # Valeur √† d√©finir plus tard\n    Smin=Smin_,\n    Smax=Smax_\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nParam√®tres financiers:\nr=0.10 sigma=0.20 K=100 T=1\n```\n:::\n:::\n\n\n## R√©sultat du sch√©ma d'Euler explicite\n\nPour √©tudier le comportement du sch√©ma d'Euler explicite, nous avons r√©alis√© des simulations en faisant varier les param√®tres $J$ (nombre de points spatiaux) et $N$ (nombre de points temporels). Nous avons consid√©r√© deux cas distincts :\n\n- Cas 1 : $N$ fix√© √† 10 et $J$ variant parmi les valeurs $\\{10, 20, 50\\}$.\n- Cas 2 : $N$ et $J$ variant simultan√©ment parmi les valeurs $\\{10, 20, 50\\}$, avec $N = J$.\n\nLes r√©sultats obtenus sont pr√©sent√©s dans les graphiques ci-dessous. Par ailleurs, pour aider √† l'interpr√©tation des r√©sultats, le r√©sultat de la condition de CFL (Courant-Friedrichs-Lewy) est √©galement affich√© sur chaque graphique.\n\n::: {#10f74d9a .cell execution_count=7}\n``` {.python .cell-code}\n# Cas 1 : N = 10, J varie dans `values`\n\nvalues = [10, 20, 50]\nN_fixed = 10\n\ncfl_records1 = []\n\nfig, axes = plt.subplots(1, 3, figsize=(24, 8), sharey=False)\nfor j, J_ in enumerate(values):\n    params['N'] = N_fixed\n    params['J'] = J_\n\n    ee = SchemeEE(**params)\n    U, t = ee.solve()\n    s = ee.s\n    dt = ee.dt\n\n    #CFL condition\n    CFL = dt / (ee.h ** 2) * (ee.sigma ** 2) * (ee.Smax ** 2)\n\n    # Enregistrement dans la table\n    cfl_records1.append({\n        \"N\": N_fixed,\n        \"J\": J_,\n        \"CFL\": CFL\n    })\n\n    ax = axes[j]\n    ax.plot(s, U, label=\"Prix option\")\n    ax.plot(s, ee.phi(s), 'k--', label=\"Payoff\")\n\n    ax.set_title(f\"N = {N_fixed}, J = {J_}\")\n    ax.set_xlabel(\"s\")\n    if j == 0:\n        ax.set_ylabel(\"u(t,s)\")\n    ax.legend()\n\nplt.suptitle(\n    f\"Evolution du prix du put europ√©en -- Scheme {ee.scheme_name}, N fix√© √† {N_fixed}\",\n    fontsize=16\n)\nplt.tight_layout(rect=[0, 0, 1, 0.95])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](edp_european_opt_files/figure-html/cell-8-output-1.png){}\n:::\n:::\n\n\n::: {#52085352 .cell execution_count=8}\n``` {.python .cell-code}\n# Cas 2 : N = J avec N, J dans `values`\nvalues = [10, 20, 50]\ncfl_records2 = []\n\nfig, axes = plt.subplots(1, 3, figsize=(24, 8), sharey=False)\nfor j, N_ in enumerate(values):\n    params['N'] = N_\n    params['J'] = N_\n\n    ee = SchemeEE(**params)\n    U, t = ee.solve()\n    s = ee.s\n    dt = ee.dt\n\n    #CFL condition\n    CFL = dt / (ee.h ** 2) * (ee.sigma ** 2) * (ee.Smax ** 2)\n\n    cfl_records2.append({\n        \"N\": N_,\n        \"J\": N_,\n        \"CFL\": CFL\n    })\n\n    ax = axes[j]\n    ax.plot(s, U, label=\"Prix option\")\n    ax.plot(s, ee.phi(s), 'k--', label=\"Payoff\")\n\n    ax.set_title(f\"N = J = {N_}, CFL={CFL:.2f}\")\n    ax.set_xlabel(\"s\")\n    if j == 0:\n        ax.set_ylabel(\"u(t,s)\")\n    ax.legend()\n\nplt.suptitle(\n    f\"Evolution du prix du put europ√©en -- Scheme {ee.scheme_name}, N = J\",\n    fontsize=16\n)\nplt.tight_layout(rect=[0, 0, 1, 0.95])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](edp_european_opt_files/figure-html/cell-9-output-1.png){}\n:::\n:::\n\n\nEn analysant les graphiques ci-dessus, nous constatons que le choix de $J$ et $N$, i.e. le maillage spatial et temporel, influence la stabilit√© de l'approximation du prix du put europ√©en.\n\nDans le cas 1, avec $N$ fix√© √† 10 et $J$ variant, nous constatons que l'approximation de prix est tr√®s proche du prix du put europ√©en pour N=J=10, ce qui est attendu pour un sch√©ma stable.\nCependant, lorsque $J$ augmente, des oscillations apparaissent dans la solution num√©rique, indiquant une instabilit√© du sch√©ma.\n\nPar ailleurs, dans le cas 2, o√π $N$ et $J$ varient simultan√©ment avec $N=J$, nous observons √©galement des oscillations et des instabilit√©s pour des valeurs plus √©lev√©es de $N$ et $J$. Ce comportement instable est similaire √† celui observ√© dans le cas 1, lorsque $J$ augmente pour un $N$ fix√©.\n\nCes oscillations et instabilit√©s observ√©es dans les deux cas √©tudi√©s sont caract√©ristiques des sch√©mas explicites lorsqu'ils ne respectent pas la condition de stabilit√© requise, dite condition CFL.\nEn effet,le sch√©ma d'euler explicite est stable conditionnellement au respect de la condition CFL d√©pendant du rapport entre $\\Delta t$ et $h^2$.\n\nLa condition CFL qui, pour le sch√©ma explicite appliqu√© √† l'√©quation de Black-Scholes, peut √™tre exprim√©e comme suit : $\\frac{\\Delta t}{h^2} \\leq \\frac{1}{2 \\sigma^2 Smax^2}$.Cette condition impose une relation entre le pas de temps $\\Delta t$ et le pas d'espace h. De fait, lorsque J augmente et N diminue, cette condition de stabilit√© peut √™tre viol√©e. Dans notre cas, lorsque J=50 et N=10 ou N=50, la condition CFL n'est pas respect√©e comme on peut l'observer dans le tableau ci-dessous, ce qui explique les oscillations et l'instabilit√© observ√©es dans les r√©sultats num√©riques.\n\n::: {#957a823a .cell execution_count=9}\n``` {.python .cell-code}\ncfl_df1 = pd.DataFrame(cfl_records1)  # Cas 1 : N fix√©\ncfl_df2 = pd.DataFrame(cfl_records2)  # Cas 2 : N = J\n\ncfl_df1 = cfl_df1.rename(columns={\"CFL\": \"CFL (N=10)\"})\ncfl_df2 = cfl_df2.rename(columns={\"CFL\": \"CFL (N=J)\"})\n\ncfl_table = pd.merge(\n    cfl_df1[[\"J\", \"CFL (N=10)\"]],\n    cfl_df2[[\"J\", \"CFL (N=J)\"]],\n    on=\"J\",\n    how=\"inner\"\n)\n\ncfl_table\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>J</th>\n      <th>CFL (N=10)</th>\n      <th>CFL (N=J)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>10</td>\n      <td>0.484</td>\n      <td>0.4840</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>20</td>\n      <td>1.764</td>\n      <td>0.8820</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>50</td>\n      <td>10.404</td>\n      <td>2.0808</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nPour mieux comprendre l'origine des oscillations, nous avons √©tudi√© la matrice d'amplification du sch√©ma explicite pour N=10 et J=50. La matrice d'amplification est d√©finie par $B:= I - dt*A$ o√π A est la matrice tridiagonale associ√©e au sch√©ma implicite. En calculant les valeurs propres de cette matrice, nous pouvons analyser la stabilit√© du sch√©ma.\n\nEn effet, cette matrice intervient dans l'√©volution de la solution num√©rique √† chaque pas de temps, et on a :\n$$\n||U^n||_2 <= ||B||^n ||U^0||_2, \\quad \\forall n \\geq 0.$$\n\nSi la norme de B est sup√©rieure √† 1, alors les valeurs prises par la solution num√©rique peuvent cro√Ætre de mani√®re exponentielle par rapport √† la condition initiale, conduisant √† des erreurs d'approximation possiblement importantes, des oscillations et ainsi une instabilit√© dans la solution num√©rique.\nPour savoir si la norme de B est sup√©rieure √† 1, nous avons calcul√© le spectre de B et constat√© que la valeur absolue de la plus grande valeur propre d√©passe 1. Cela confirme que le sch√©ma explicite est instable pour les param√®tres choisis, ce qui explique les oscillations observ√©es dans les r√©sultats num√©riques.\n\nPour cette raison, nous avons test√© d'autres sch√©mas num√©riques tels que le sch√©ma d'Euler implicite et le sch√©ma de Crank-Nicolson, qui sont connus pour leur stabilit√© inconditionnelle.\n\n::: {#e019baf3 .cell execution_count=10}\n``` {.python .cell-code}\n# Param√®tres\nparams['N'] = 10\nparams['J'] = 50\n\nee = SchemeEE(**params)\nee.solve()\n\n# Matrice d'amplification\nA = ee.A.toarray()\nB = np.eye(ee.J) - ee.dt * A\n\n# Valeurs propres\neigenvalues = lng.eigvals(B)\nspectral_radius = np.max(np.abs(eigenvalues))\nnorm_B = lng.norm(B, 2)\n\n# Tableau r√©capitulatif\ndf_spectrum = pd.DataFrame({\n    \"Valeur propre\": eigenvalues,\n    \"|Valeur propre|\": np.abs(eigenvalues)\n}).sort_values(\"|Valeur propre|\", ascending=False)\n\n# Affichage\nprint(\"=== Analyse de stabilit√© du sch√©ma explicite ===\\n\")\n\nprint(\"Param√®tres num√©riques :\")\nprint(f\"  N = {ee.N},  J = {ee.J},  dt = {ee.dt:.2f},  h  = {ee.h:.2f}\\n\")\n\nprint(\"10 plus grandes valeurs propres de B (tri√©es par module d√©croissant) :\")\nprint(df_spectrum.head(10).to_string(index=False))\n\nprint(\"Norme matricielle induite (norme 2) :\")\nprint(f\"  ||B||‚ÇÇ = {norm_B:.6f}\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n=== Analyse de stabilit√© du sch√©ma explicite ===\n\nParam√®tres num√©riques :\n  N = 10,  J = 50,  dt = 0.10,  h  = 3.92\n\n10 plus grandes valeurs propres de B (tri√©es par module d√©croissant) :\n Valeur propre  |Valeur propre|\n    -16.469570        16.469570\n    -14.218162        14.218162\n    -12.525602        12.525602\n    -11.138073        11.138073\n     -9.955409         9.955409\n     -8.924546         8.924546\n     -8.012865         8.012865\n     -7.198391         7.198391\n     -6.465369         6.465369\n     -5.801977         5.801977\nNorme matricielle induite (norme 2) :\n  ||B||‚ÇÇ = 16.473976\n\n```\n:::\n:::\n\n\n## R√©sultat du sch√©ma d'Euler implicite et de Crank-Nicolson\n\n### Cas du sch√©ma d'Euler implicite\n\nPour √©tudier le comportement du sch√©ma d'Euler implicite, nous nous sommes directement plac√©s dans le cas o√π N=10 et J=50, qui avait montr√© des oscillations dans le sch√©ma explicite. Les r√©sultats obtenus sont pr√©sent√©s dans le graphique ci-dessous. Comme on peut le constater, le sch√©ma d'Euler implicite produit une approximation stable et sans oscillations du prix du put europ√©en, m√™me pour des valeurs √©lev√©es de N et J. Cela confirme la stabilit√© inconditionnelle du sch√©ma implicite, qui ne d√©pend pas de la relation entre le pas de temps et le pas spot.\n\n::: {#779e8bb2 .cell execution_count=11}\n``` {.python .cell-code}\nparams['J'] = 50\nparams['N'] = 10\n\nprint(\"Param√®tres financiers:\")\nprint(\"r=%.2f\" %r_, \"sigma=%.2f\" %sigma_, \"K=%.0f\" %K_, \"T=%.0f\" %T_)\n\nprint(\"Param√®tres num√©riques:\")\nprint(\"J=%.0f\" %params['J'], \"N=%.0f\" %params['N'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nParam√®tres financiers:\nr=0.10 sigma=0.20 K=100 T=1\nParam√®tres num√©riques:\nJ=50 N=10\n```\n:::\n:::\n\n\n::: {#2697280d .cell execution_count=12}\n``` {.python .cell-code}\nei = SchemeEI(**params)\nU,t = ei.solve()\ns = ei.s\ndt = ei.dt\n\nplt.figure(figsize=(6, 5))\nplt.plot(s,U,label=\"t=%.2f\" %(t+dt))\nplt.plot(s,ei.phi(s), 'k--', label=\"payoff\")\nplt.xlabel(\"s\")\nplt.ylabel(\"u(t,s)\")\nplt.title(\"Evolution du prix du put europ√©en au cours du temps [Euler Implicite]\")\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](edp_european_opt_files/figure-html/cell-13-output-1.png){}\n:::\n:::\n\n\n### Cas du sch√©ma de Crank-Nicolson\n\nLe sch√©ma de Crank-Nicolson, quant √† lui, est une m√©thode implicite qui combine les avantages des sch√©mas explicites et implicites. Il est bas√© sur une moyenne pond√©r√©e des valeurs aux temps n et n+1, ce qui permet d'obtenir une meilleure pr√©cision temporelle tout en maintenant la stabilit√©. Lors de l'√©tude du sch√©ma de Crank-Nicolson, nous avons √©galement choisi les param√®tres N=10 et J=50. Les r√©sultats obtenus sont pr√©sent√©s dans le graphique ci-dessous. Comme on peut le constater, le sch√©ma de Crank-Nicolson produit √©galement une approximation stable et sans oscillations du prix du put europ√©en, confirmant ainsi sa stabilit√© inconditionnelle.\n\n::: {#a8024875 .cell execution_count=13}\n``` {.python .cell-code}\nparams['J'] = 50\nparams['N'] = 10\n\nprint(\"Param√®tres financiers:\")\nprint(\"r=%.2f\" %r_, \"sigma=%.2f\" %sigma_, \"K=%.0f\" %K_, \"T=%.0f\" %T_)\n\nprint(\"Param√®tres num√©riques:\")\nprint(\"J=%.0f\" %params['J'], \"N=%.0f\" %params['N'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nParam√®tres financiers:\nr=0.10 sigma=0.20 K=100 T=1\nParam√®tres num√©riques:\nJ=50 N=10\n```\n:::\n:::\n\n\n::: {#3a5bf5c8 .cell execution_count=14}\n``` {.python .cell-code}\ncn = SchemeCN(**params)\nU,t = cn.solve()\ns = cn.s\ndt = cn.dt\n\nplt.figure(figsize=(6, 5))\nplt.plot(s,U,label=\"t=%.2f\" %(t+dt))\nplt.plot(s,cn.phi(s), 'k--', label=\"payoff\")\nplt.xlabel(\"s\")\nplt.ylabel(\"u(t,s)\")\nplt.title(\"Evolution du prix du put europ√©en au cours du temps [Crank-Nicolson]\")\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](edp_european_opt_files/figure-html/cell-15-output-1.png){}\n:::\n:::\n\n\n# Compl√©ment 1: Black and Scholes\n\n## M√©thodes\n\nAfin de comparer les r√©sultats num√©riques obtenus avec les diff√©rents $\\theta-$sch√©mas au prix th√©orique du put europ√©en, nous avons impl√©ment√© la formule de Black and Scholes dans une fonction Python. Cette fonction calcule le prix du put en utilisant les param√®tres financiers tels que le prix de l'actif sous-jacent, le prix d'exercice, le taux d'int√©r√™t sans risque, la volatilit√© et le temps jusqu'√† l'√©ch√©ance.\n\nNous analysons la convergence des sch√©mas num√©riques consid√©r√©s, ainsi que les ordres de convergence.\nLa convergence est ensuite √©tudi√©e num√©riquement en comparant les prix obtenus par les sch√©mas avec la solution analytique du put europ√©en, et les ordres de convergence sont estim√©s √† partir du comportement asymptotique de l‚Äôerreur lorsque les pas de temps et d‚Äôespace tendent vers z√©ro.\n\nPour estimer num√©riquement l'ordre de convergence des sch√©mas, on utilise la relation $e_k \\sim C h_k^\\alpha$, o√π $C$ est une constante ind√©pendante de $h_k$ et $\\alpha$ est l'ordre de convergence du sch√©ma, $h_k$ √©tant le pas de discr√©tisation spatial, d√©fini par $h_k = \\frac{S_{max} - S_{min}}{J_k + 1}$, et $J_k$ le nombre de points spatiaux utilis√©s dans la discr√©tisation. De fait, on obtient l'ordre de convergence $\\alpha$ en comparant les erreurs $e_k$ et $e_{k+1}$ pour deux maillages successifs. D'o√π\n$$\\alpha_k\n= \\frac{\\log\\!\\left(\\frac{e_{k+1}}{e_k}\\right)}\n       {\\log\\!\\left(\\frac{h_{k+1}}{h_k}\\right)}.\n$$\n\nNous consid√©rons deux grilles de discr√©tisation successives d√©finies par les couples $(N_k, J_k)$, √† savoir $N=J$ et $N = \\frac{J^2}{10}$, avec $J \\in \\{10, 20, 40, 80, 160\\}$.\n\n::: {#018b2ee7 .cell execution_count=15}\n``` {.python .cell-code}\nprint(\"Param√®tres financiers:\")\nSval = 80\nprint(\"r=%.2f\" %r_, \"sigma=%.2f\" %sigma_, \"K=%.0f\" %K_, \"T=%.0f\" %T_, \"Sval=%.2f\" %Sval)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nParam√®tres financiers:\nr=0.10 sigma=0.20 K=100 T=1 Sval=80.00\n```\n:::\n:::\n\n\n::: {#00ec9a73 .cell execution_count=16}\n``` {.python .cell-code}\n# Implementation de la formule de Black and Scholes\ndef dplus(x,K,r,sigma,T,t):\n    tau = T-t\n    numerator = np.log(x/K) + tau * (r + 0.5*sigma**2)\n    denominator = sigma * np.sqrt(tau)\n    return numerator / denominator\n\ndef dmoins(dplus_,sigma,tau):\n    return dplus_ - sigma * np.sqrt(tau)\n\ndef compute_BS_price(x,K,r,sigma,T,t=0,type_='call'):\n    tau = T-t\n    dplus_ = dplus(x,K,r,sigma,T,t)\n    dmoins_ = dmoins(dplus_,sigma,tau)\n    if type_ == 'call':\n        return x*stats.norm.cdf(dplus_) - K * np.exp(-r*tau) * stats.norm.cdf(dmoins_)\n    elif type_=='put':\n        return K* np.exp(-r*tau)* stats.norm.cdf(-dmoins_) - x * stats.norm.cdf(-dplus_)\n```\n:::\n\n\n::: {#64c91640 .cell execution_count=17}\n``` {.python .cell-code}\nprice_BS = compute_BS_price(Sval, params['K'], params['r'], params['sigma'], params['T'], t=0, type_='put')\nprint(\"Prix th√©orique du put pour S=%.2f : %.4f\" %(Sval, price_BS))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrix th√©orique du put pour S=80.00 : 13.2737\n```\n:::\n:::\n\n\n::: {#e8b7556e .cell execution_count=18}\n``` {.python .cell-code}\ndef get_convergence_table(N_grid, J_grid, params, Sval, scheme_class):\n\n    est_prices = []\n    errex = []\n    errors = []\n    cpu_times = []\n\n    # Prix exact (identique pour tous)\n    BS_price = compute_BS_price(\n        Sval, params['K'], params['r'],\n        params['sigma'], params['T'],\n        t=0, type_='put'\n    )\n\n    for N, J in zip(N_grid, J_grid):\n        params['N'] = N\n        params['J'] = J\n\n        start = time.time()\n        scheme = scheme_class(**params)\n        U, _ = scheme.solve()\n        tcpu = time.time() - start\n\n        price_est = scheme.interpolate(Sval, U)\n\n        est_prices.append(price_est)\n        errex.append(abs(price_est - BS_price))\n        cpu_times.append(tcpu)\n\n    est_prices = np.array(est_prices)\n    errors = np.zeros(len(est_prices))\n    errors[1:] = np.abs(np.diff(est_prices))\n    errex = np.array(errex)\n    cpu_times = np.array(cpu_times)\n\n    # Ordre de convergence global\n    alpha = np.zeros(len(errors))\n    h_step = (params[\"Smax\"] - params[\"Smin\"]) / (J_grid + 1)\n    alpha[1:] = np.log(errex[:-1] / errex[1:]) / np.log(h_step[:-1] / h_step[1:])\n\n    df = pd.DataFrame({\n        \"J\": J_grid,\n        \"N\": N_grid,\n        \"U(s)\": est_prices,\n        \"error\": errors,\n        \"alpha\": alpha,\n        \"errex\": errex,\n        \"tcpu\": cpu_times\n    })\n\n    return df.round(6)\n```\n:::\n\n\n## R√©sultats\n\n<!-- On constate que par rapport au schema d'euler implicite, le schema de Crank-Nicolson offre une meilleure pr√©cision temporelle tout en maintenant la stabilit√©, ce qui le rend particuli√®rement adapt√© pour la r√©solution des EDP en finance.\nC'est le sch√©ma qui a par ailleurs l'ordre de convergence le plus √©lev√© parmi les deux sch√©mas √©tudi√©s. -->\n\nOn constate que les trois sch√©mas pr√©sentent des comportements tr√®s contrast√©s en termes de stabilit√©, ordre de convergence et co√ªt de calcul lorsque l‚Äôon impose $N = J$.\n\nOn observe tout d‚Äôabord que le sch√©ma d‚ÄôEuler explicite ne peut pas √™tre consid√©r√© comme fiable dans ce cadre, comme pr√©cis√© pr√©c√©demment.\nPour des maillages grossiers, l‚Äôerreur semble initialement d√©cro√Ætre et l‚Äôordre estim√© est proche de 2, ce qui pourrait sugg√©rer une bonne convergence. Cependant, d√®s que la discr√©tisation devient plus fine, la solution diverge et on observe une explosion num√©rique √† partir de $N = J = 80$ qui montre clairement que la condition de stabilit√© n‚Äôest plus satisfaite lorsque $\\Delta t$ et $\\Delta s$ sont raffin√©s simultan√©ment.\n\nLe sch√©ma d‚ÄôEuler implicite est parfaitement stable sur toute la plage de discr√©tisations consid√©r√©e. L‚Äôerreur d√©cro√Æt de fa√ßon r√©guli√®re lorsque $N = J$ augmente, sans aucune instabilit√© num√©rique. De plus, l‚Äôordre de convergence estim√© reste inf√©rieur √† 2 et tend progressivement vers une valeur proche de 1, ce qui est coh√©rent avec le fait que, lorsque $\\Delta t \\sim \\Delta s$, l‚Äôerreur temporelle d‚Äôordre 1 domine l‚Äôerreur spatiale.\n\nEnfin, on constate que le sch√©ma de Crank‚ÄìNicolson pr√©sente le comportement le plus satisfaisant. Il est stable sur toute la grille, l‚Äôerreur d√©cro√Æt rapidement et l‚Äôordre de convergence estim√© est tr√®s proche de 2 d√®s les maillages interm√©diaires, puis se stabilise autour de cette valeur pour les maillages fins. Ce r√©sultat est parfaitement conforme √† la th√©orie, puisque le sch√©ma est d‚Äôordre 2 √† la fois en temps et en espace.\n\nPour conclure, lorsque $N = J$, en termes de temps de calcul, le sch√©ma EE est certes le plus rapide sur les grilles grossi√®res, avec des temps de simulation de l‚Äôordre de la milliseconde, mais cet avantage est sans int√©r√™t pratique puisque la solution devient totalement inutilisable pour des maillages fins.\nLe sch√©ma implicite constitue une solution robuste mais relativement co√ªteuse et moins pr√©cise. En effet, il n√©cessite la r√©solution d‚Äôun syst√®me lin√©aire √† chaque pas de temps. Cela se refl√®te clairement dans les temps de calcul, qui augmentent sensiblement avec le raffinement et deviennent significatifs pour les maillages fins, atteignant plus de 0.1 seconde pour $N = J = 160$.\n\nLe sch√©ma de Crank‚ÄìNicolson appara√Æt comme le meilleur compromis, combinant stabilit√©, convergence d‚Äôordre 2 et temps de calcul raisonnables.\nEn termes de co√ªt de calcul, le sch√©ma CN est plus cher que le sch√©ma explicite mais reste nettement plus efficace que le sch√©ma implicite pur. Les temps de simulation restent mod√©r√©s, m√™me pour des valeurs √©lev√©es de $N = J$, et demeurent largement compatibles avec une utilisation pratique, tout en offrant une pr√©cision bien sup√©rieure.\n\n::: {#04594a31 .cell execution_count=19}\n``` {.python .cell-code}\nN_grid = J_grid = np.array([10, 20, 40, 80, 160])\nprint(\"Cas N = J\\n\", \"=\"*75)\n\nprint(\"Convergence Table for Scheme EE:\")\nprint(get_convergence_table(N_grid, J_grid, params, Sval, SchemeEE))\n\nprint(\"=\"*75, \"\\nConvergence Table for Scheme EI:\")\nprint(get_convergence_table(N_grid, J_grid, params, Sval, SchemeEI))\n\nprint(\"=\"*75, \"\\nConvergence Table for Scheme CN:\")\nprint(get_convergence_table(N_grid, J_grid, params, Sval, SchemeCN))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCas N = J\n ===========================================================================\nConvergence Table for Scheme EE:\n     J    N          U(s)         error       alpha         errex      tcpu\n0   10   10  1.425509e+01  0.000000e+00    0.000000  9.814290e-01  0.000212\n1   20   20  1.351532e+01  7.397760e-01    2.167407  2.416540e-01  0.000158\n2   40   40  1.332033e+01  1.949870e-01    2.457937  4.666600e-02  0.000257\n3   80   80 -1.061474e+04  1.062806e+04  -18.117778  1.062801e+04  0.000558\n4  160  160 -8.121408e+69  8.121408e+69 -220.831903  8.121408e+69  0.001096\n=========================================================================== \nConvergence Table for Scheme EI:\n     J    N       U(s)     error     alpha     errex      tcpu\n0   10   10  14.448406  0.000000  0.000000  1.174743  0.000530\n1   20   20  13.642159  0.806247  1.792956  0.368496  0.000878\n2   40   40  13.386145  0.256015  1.773621  0.112482  0.001978\n3   80   80  13.310502  0.075642  1.639391  0.036839  0.003961\n4  160  160  13.287066  0.023436  1.471804  0.013403  0.009982\n=========================================================================== \nConvergence Table for Scheme CN:\n     J    N       U(s)     error     alpha     errex      tcpu\n0   10   10  14.353451  0.000000  0.000000  1.079788  0.000380\n1   20   20  13.578892  0.774559  1.953920  0.305229  0.000576\n2   40   40  13.353140  0.225752  2.011209  0.079477  0.001089\n3   80   80  13.293944  0.059195  2.005878  0.020281  0.002566\n4  160  160  13.278788  0.015156  2.002416  0.005125  0.006933\n```\n:::\n:::\n\n\n<!-- Avec $N = \\frac{J^2}{10}$, on constate que le sch√©ma explicite respecte la condition de stabilit√© de CFL, ce qui garantit la stabilit√© num√©rique de la solution. En revanche, lorsque $N = J$, la condition de CFL n'est pas respect√©e, ce qui peut entra√Æner des instabilit√©s dans la solution num√©rique.\nPar ailleurs, les ordres de convergence obtenus dans les deux cas sont similaires, ce qui sugg√®re que le choix de la relation entre $N$ et $J$ n'affecte pas significativement la pr√©cision du sch√©ma dans ce contexte particulier.\nDe m√™me, nous avons des erreurs similaires pour les deux relations entre N et J, ce qui indique que le sch√©ma de Crank-Nicolson est robuste par rapport √† ces choix de maillage temporel et spatial. -->\n\nOn constate que le choix $N = J^2/10$ modifie l‚Äôanalyse par rapport au cas $N = J$, en particulier pour le sch√©ma explicite. Alors que ce dernier √©tait instable lorsque les pas de temps et d‚Äôespace √©taient raffin√©s simultan√©ment, il devient ici parfaitement stable. L‚Äôerreur d√©cro√Æt r√©guli√®rement et l‚Äôordre de convergence est tr√®s proche de 2 sur l‚Äôensemble des maillages, ce qui montre que la condition de stabilit√© est d√©sormais respect√©e et que l‚Äôerreur spatiale domine. Le sch√©ma EE retrouve ainsi une convergence th√©oriquement optimale, tout en conservant un co√ªt de calcul globalement inf√©rieur √† celui des sch√©mas implicites.\n\nLe sch√©ma d‚ÄôEuler implicite reste, comme pr√©c√©demment, inconditionnellement stable. Cependant, contrairement au cas $N = J$, l‚Äôordre de convergence n‚Äôest plus limit√© par l‚Äôerreur temporelle et tend lui aussi vers 2 lorsque $J$ augmente. Cette am√©lioration de la pr√©cision se fait au prix d‚Äôun co√ªt de calcul tr√®s √©lev√©, les temps de simulation augmentant fortement avec $N$, ce qui rend le sch√©ma peu comp√©titif pour des grilles fines.\n\nLe sch√©ma de Crank‚ÄìNicolson conserve un comportement tr√®s r√©gulier et conforme √† la th√©orie. Il est stable, pr√©sente une convergence d‚Äôordre 2 et offre des erreurs comparables √† celles du sch√©ma explicite stabilis√©. En revanche, son co√ªt de calcul augmente sensiblement avec le raffinement et devient proche de celui du sch√©ma implicite pour les maillages les plus fins.\n\nAinsi, contrairement au cas $N = J$ o√π Crank‚ÄìNicolson apparaissait clairement comme le meilleur compromis, le r√©gime $N = J^2/10$ met en √©vidence l‚Äôefficacit√© du sch√©ma explicite, qui combine ici stabilit√©, convergence d‚Äôordre 2 et temps de calcul plus faibles, √† condition d‚Äôaccepter une contrainte forte sur le pas de temps.\n\n::: {#d60cf68f .cell execution_count=20}\n``` {.python .cell-code}\nN_grid = np.array([(j**2)/10 for j in J_grid]).astype(int)\n\nprint(\"Cas N = J^2/10\\n\", \"=\"*75)\nprint(\"Convergence Table for Scheme EE:\")\nprint(get_convergence_table(N_grid, J_grid, params, Sval, SchemeEE))\n\nprint(\"=\"*75, \"\\nConvergence Table for Scheme EI:\")\nprint(get_convergence_table(N_grid, J_grid, params, Sval, SchemeEI))\n\nprint(\"=\"*75, \"\\nConvergence Table for Scheme CN:\")\nprint(get_convergence_table(N_grid, J_grid, params, Sval, SchemeCN))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCas N = J^2/10\n ===========================================================================\nConvergence Table for Scheme EE:\n     J     N       U(s)     error     alpha     errex      tcpu\n0   10    10  14.255092  0.000000  0.000000  0.981429  0.000155\n1   20    40  13.547634  0.707459  1.973300  0.273971  0.000214\n2   40   160  13.345106  0.202528  2.009007  0.071443  0.000719\n3   80   640  13.291930  0.053175  2.002965  0.018267  0.002883\n4  160  2560  13.278284  0.013646  2.000790  0.004621  0.010337\n=========================================================================== \nConvergence Table for Scheme EI:\n     J     N       U(s)     error     alpha     errex      tcpu\n0   10    10  14.448406  0.000000  0.000000  1.174743  0.000565\n1   20    40  13.611061  0.837345  1.929307  0.337398  0.001650\n2   40   160  13.361562  0.249499  2.010421  0.087899  0.006941\n3   80   640  13.296062  0.065500  2.007975  0.022399  0.031444\n4  160  2560  13.279318  0.016744  2.003733  0.005655  0.157797\n=========================================================================== \nConvergence Table for Scheme CN:\n     J     N       U(s)     error     alpha     errex      tcpu\n0   10    10  14.353451  0.000000  0.000000  1.079788  0.000538\n1   20    40  13.579386  0.774065  1.951418  0.305723  0.001003\n2   40   160  13.353328  0.226058  2.010092  0.079665  0.003859\n3   80   640  13.293996  0.059332  2.005652  0.020333  0.019154\n4  160  2560  13.278801  0.015195  2.002383  0.005138  0.106421\n```\n:::\n:::\n\n\n# Compl√©ment 2 : Call option\n\nDans ce compl√©ment, nous √©tendons l‚Äô√©tude pr√©c√©dente au cas de l‚Äôoption call europ√©enne, en adaptant les conditions initiales et aux limites du probl√®me de Black‚ÄìScholes. La structure des sch√©mas num√©riques aux diff√©rences finies (Euler explicite, Euler implicite et Crank‚ÄìNicolson) reste inchang√©e, seule la nature du payoff et des conditions aux fronti√®res √©tant modifi√©e. Notre objectif est de v√©rifier que les propri√©t√©s observ√©es pr√©c√©demment pour le put europ√©en (en particulier en termes de stabilit√© et de convergence) se retrouvent √©galement dans le cas du call. Les r√©sultats num√©riques obtenus et pr√©sent√©s ci apr√®s permettent de confirmer la robustesse des sch√©mas √©tudi√©s vis-√†-vis du type d‚Äôoption consid√©r√©e.\n\n## Choix d'impl√©mentations\n\nL‚Äôimpl√©mentation des sch√©mas num√©riques est rest√©e globalement inchang√©e par rapport au cas du put europ√©en. La m√™me classe de base SchemeBase est utilis√©e pour d√©finir la grille de discr√©tisation et les op√©rateurs num√©riques, tandis que seules la condition initiale, correspondant au payoff du call europ√©en, ainsi que les conditions aux limites ont √©t√© adapt√©es. Les sch√©mas d‚ÄôEuler explicite, d‚ÄôEuler implicite et de Crank‚ÄìNicolson sont impl√©ment√©s de mani√®re identique via les classes SchemeEE, SchemeEI et SchemeCN.\n\n::: {#074854d1 .cell execution_count=21}\n``` {.python .cell-code}\nclass SchemeBase(ABC):\n    \"\"\"\n    Classe de base pour les sch√©mas num√©riques de l'√©quation de Black-Scholes.\n    \"\"\"\n    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):\n        # Financial parameters\n        self.r = r\n        self.sigma = sigma\n        self.K = K\n        self.T = T\n\n        # Numerical parameters\n        self.N = N\n        self.J = J\n        self.Smin = Smin\n        self.Smax = Smax\n\n        # Grids\n        self.dt = T / N\n        self.h = (Smax - Smin) / (J + 1)\n        self.s = Smin + self.h * np.arange(1, J + 1)\n\n        # Operator\n        self.A, self.alpha, self.beta = self._build_matrix_A()\n\n    def phi(self, s):\n        \"\"\"\n        Condition initiale (payoff) pour un call europ√©en.\n        ùúô(s) = max(s - K, 0)\n        \"\"\"\n        return np.maximum(s-self.K, 0)\n\n    def uleft(self, t):\n        \"\"\"\n        Condition aux limites √† gauche pour un call europ√©en.\n        \"\"\"\n        return 0.0\n\n    def uright(self, t):\n        \"\"\"\n        Condition aux limites √† droite pour un put europ√©en.\n        \"\"\"\n        return self.Smax - self.K * np.exp(-self.r * t)\n\n    def _build_matrix_A(self):\n        \"\"\"\n        Matrice d'amplification A.\n        \"\"\"\n        alpha = 0.5 * self.sigma**2 * (self.s**2 / self.h**2)\n        beta  = self.r * self.s / (2 * self.h)\n\n        lower = -alpha[1:] + beta[1:]        # sous-diagonale\n        main  = 2 * alpha + self.r            # diagonale principale\n        upper = -alpha[:-1] - beta[:-1]       # sur-diagonale\n\n        A = diags(\n            diagonals=[lower, main, upper],\n            offsets=[-1, 0, 1],\n            shape=(self.J, self.J),\n            format=\"csr\"\n        )\n\n        return A, alpha, beta\n\n    def q(self, t):\n        \"\"\"\n        Vecteur des conditions aux limites.\n        \"\"\"\n        y = np.zeros(self.J)\n        y[0]  = (-self.alpha[0] + self.beta[0]) * self.uleft(t)\n        y[-1] = (-self.alpha[-1] - self.beta[-1]) * self.uright(t)\n        return y\n\n    def interpolate(self, Sval, U):\n        \"\"\"\n        Interpolation lin√©aire pour obtenir la valeur approxim√©e d'un put\n        en un point spot Sval donn√©.\n        \"\"\"\n        if Sval <= self.Smin:\n            return self.uleft(self.T)\n        elif Sval >= self.Smax:\n            return self.uright(self.T)\n        else:\n            return np.interp(Sval, self.s, U)\n\n    # Abstract method\n    @abstractmethod\n    def solve(self):\n        \"\"\"\n        M√©thode abstraite de r√©solution du sch√©ma num√©rique.\n        \"\"\"\n        raise NotImplementedError(\"M√©thode solve() √† impl√©menter dans la classe fille\")\n```\n:::\n\n\n::: {#bd22373c .cell execution_count=22}\n``` {.python .cell-code}\nclass SchemeEE(SchemeBase):\n    \"\"\"\n    Sch√©ma d'Euler explicite.\n    \"\"\"\n    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):\n        super().__init__(r, sigma, K, T, N, J, Smin, Smax)\n        self.scheme_name = \"Euler Explicite\"\n\n    def solve(self):\n        \"\"\"\n        R√©solution du sch√©ma d'Euler explicite.\n        \"\"\"\n        U = self.phi(self.s)\n\n        for n in range(self.N):\n            t = n * self.dt\n            U = U - self.dt * (self.A @ U + self.q(t))\n\n        return U,t\n```\n:::\n\n\n::: {#ea595d24 .cell execution_count=23}\n``` {.python .cell-code}\nclass SchemeEI(SchemeBase):\n    \"\"\"\n    Sch√©ma d'Euler implicite.\n    \"\"\"\n    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):\n        super().__init__(r, sigma, K, T, N, J, Smin, Smax)\n        self.scheme_name = \"Euler Implicite\"\n\n    def solve(self):\n        U = self.phi(self.s)\n        I = eye(self.J, format=\"csr\")\n\n        for n in range(self.N):\n            t = n * self.dt\n            U = spsolve(I + self.dt * self.A, U - self.dt * self.q(t))\n\n        return U,t\n```\n:::\n\n\n::: {#2a00a9eb .cell execution_count=24}\n``` {.python .cell-code}\nclass SchemeCN(SchemeBase):\n    \"\"\"\n    Sch√©ma de Crank-Nicolson.\n    \"\"\"\n    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):\n        super().__init__(r, sigma, K, T, N, J, Smin, Smax)\n        self.scheme_name = \"Crank-Nicolson\"\n\n    def solve(self):\n        U = self.phi(self.s)\n        I = eye(self.J, format=\"csr\")\n        factor_minus = I - 0.5 * self.dt * self.A\n        factor_plus = I + 0.5 * self.dt * self.A\n\n        for n in range(self.N):\n            t = n * self.dt\n\n            U = spsolve(factor_plus, factor_minus@U - self.dt * self.q(t))\n        return U,t\n```\n:::\n\n\n## R√©sultats des sch√©mas num√©riques\n\n### Cas du sch√©ma d'Euler explicite\n\nLes r√©sultats pr√©c√©dents ont montr√© que le sch√©ma d‚ÄôEuler explicite est conditionnellement stable en fonction de $J$, $N$ et de la condition CFL. Ici, nous l‚Äôappliquons √† un call europ√©en en utilisant les m√™mes configurations que pour le put :\n- (1) $N = 10$ et $J \\in {10, 20, 50}$,\n- (2) $N = J \\in {10, 20, 50}$.\n\nLes r√©sultats, accompagn√©s de l‚Äôindication de la condition CFL, sont pr√©sent√©s dans les graphiques ci‚Äëdessous.\n\n::: {#cef2cf4f .cell execution_count=25}\n``` {.python .cell-code}\n# Cas 1 : N = 10, J varie dans `values` pour le call europ√©en\nvalues = [10, 20, 50]\nN_fixed = 10\ncfl_records1 = []\n\nfig, axes = plt.subplots(1, 3, figsize=(24, 8), sharey=False)\nfor j, J_ in enumerate(values):\n    params['N'] = N_fixed\n    params['J'] = J_\n\n    ee = SchemeEE(**params)\n    U, t = ee.solve()\n    s = ee.s\n    dt = ee.dt\n\n    # Condition CFL\n    CFL = dt / (ee.h ** 2) * (ee.sigma ** 2) * (ee.Smax ** 2)\n\n    # Enregistrement\n    cfl_records1.append({\n        \"N\": N_fixed,\n        \"J\": J_,\n        \"CFL\": CFL\n    })\n\n    ax = axes[j]\n    ax.plot(s, U, label=\"Prix option\")\n    ax.plot(s, ee.phi(s), 'k--', label=\"Payoff\")\n\n    ax.set_title(f\"N = {N_fixed}, J = {J_}, CFL={CFL:.2f}\")\n    ax.set_xlabel(\"s\")\n    if j == 0:\n        ax.set_ylabel(\"u(t,s)\")\n    ax.legend()\n\nplt.suptitle(\n    f\"Evolution du prix du call europ√©en -- Scheme {ee.scheme_name}, N fix√© √† {N_fixed}\",\n    fontsize=16\n)\nplt.tight_layout(rect=[0, 0, 1, 0.95])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](edp_european_opt_files/figure-html/cell-26-output-1.png){}\n:::\n:::\n\n\n::: {#e12a1fbd .cell execution_count=26}\n``` {.python .cell-code}\n#Cas 2 : N = J avec N, J dans `values` pour le call europ√©en\ncfl_records2 = []\n\nfig, axes = plt.subplots(1, 3, figsize=(24, 8), sharey=False)\nfor j, N_ in enumerate(values):\n    params['N'] = N_\n    params['J'] = N_\n\n    ee = SchemeEE(**params)\n    U, t = ee.solve()\n    s = ee.s\n    dt = ee.dt\n\n    # Condition CFL\n    CFL = dt / (ee.h ** 2) * (ee.sigma ** 2) * (ee.Smax ** 2)\n\n    cfl_records2.append({\n        \"N\": N_,\n        \"J\": N_,\n        \"CFL\": CFL\n    })\n\n    ax = axes[j]\n    ax.plot(s, U, label=\"Prix option\")\n    ax.plot(s, ee.phi(s), 'k--', label=\"Payoff\")\n\n    ax.set_title(f\"N = J = {N_}, CFL={CFL:.2f}\")\n    ax.set_xlabel(\"s\")\n    if j == 0:\n        ax.set_ylabel(\"u(t,s)\")\n    ax.legend()\n\nplt.suptitle(\n    f\"Evolution du prix du call europ√©en -- Scheme {ee.scheme_name}, N = J\",\n    fontsize=16\n)\nplt.tight_layout(rect=[0, 0, 1, 0.95])\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](edp_european_opt_files/figure-html/cell-27-output-1.png){}\n:::\n:::\n\n\nComme pour le put, le sch√©ma d‚ÄôEuler explicite pour le call est stable pour de petites valeurs de $J$ et $N$, et devient instable lorsque la condition CFL n‚Äôest pas respect√©e, entra√Ænant des oscillations.\n\n### Cas des sch√©mas d'Euler implicite et de Crank-Nicolson\n\n\n\n\nLes sch√©mas d'Euler implicite et de Crank-Nikolson, appliqu√©s au cas du call europ√©en, demeurent inconditionnellement stables. Ils sont test√©s sur la configuration N= 10 et J= 50, qui avait conduit √† des instabilit√©s et √† des oscillations pour le schema explicite. Les r√©sultats obtenus montrent une approximation stable et sans oscillations du prix du call.\n\n::: {#f49045f0 .cell execution_count=27}\n``` {.python .cell-code}\nparams['J'] = 50\nparams['N'] = 10\n\nprint(\"Param√®tres financiers:\")\nprint(\"r=%.2f\" %r_, \"sigma=%.2f\" %sigma_, \"K=%.0f\" %K_, \"T=%.0f\" %T_)\n\nprint(\"Param√®tres num√©riques:\")\nprint(\"J=%.0f\" %params['J'], \"N=%.0f\" %params['N'])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nParam√®tres financiers:\nr=0.10 sigma=0.20 K=100 T=1\nParam√®tres num√©riques:\nJ=50 N=10\n```\n:::\n:::\n\n\n::: {#f0153138 .cell execution_count=28}\n``` {.python .cell-code}\nei = SchemeEI(**params)\nU,t = ei.solve()\ns = ei.s\ndt = ei.dt\n\nplt.figure(figsize=(6, 5))\nplt.plot(s,U,label=\"t=%.2f\" %(t+dt))\nplt.plot(s,ei.phi(s), 'k--', label=\"payoff\")\nplt.xlabel(\"s\")\nplt.ylabel(\"u(t,s)\")\nplt.title(\"Evolution du prix du call europ√©en au cours du temps [Euler Implicite]\")\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](edp_european_opt_files/figure-html/cell-29-output-1.png){}\n:::\n:::\n\n\n::: {#79632e55 .cell execution_count=29}\n``` {.python .cell-code}\ncn = SchemeCN(**params)\nU,t = cn.solve()\ns = cn.s\ndt = cn.dt\n\nplt.figure(figsize=(6, 5))\nplt.plot(s,U,label=\"t=%.2f\" %(t+dt))\nplt.plot(s,cn.phi(s), 'k--', label=\"payoff\")\nplt.xlabel(\"s\")\nplt.ylabel(\"u(t,s)\")\nplt.title(\"Evolution du prix du call europ√©en au cours du temps [Crank-Nicolson]\")\nplt.legend()\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](edp_european_opt_files/figure-html/cell-30-output-1.png){}\n:::\n:::\n\n\n",
    "supporting": [
      "edp_european_opt_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}