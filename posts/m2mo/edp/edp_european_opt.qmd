---
title: "Finite difference Methods for European Options"
subtitle: "EDP in finance"
author:
  - name: Cheryl KOUADIO
  - name: Marilene Kougoum
categories: [paper,m2mo,edp]
date: "2026-01-14"
jupyter: python3
---


# Introduction

Dans ce tp, nous √©tudion des sch√©mas aux diff√©rences finies pour l'√©quation de Black-Scholes pos√©e dans les variables primitives, apr√®s localisation dans un rectangle dans les variables temps-spot.

Ces sch√©mas nous permettront d'obtenir une approximation num√©rique de la fonction de prix d'un put europ√©en $v(t,s)$, avec $t \in [0,T]$ et $s \in [S_{min}, S_{max}]$. Cette fonction satisfait l'√©quation de Black-Scholes sur le domaine tronqu√© $\Omega = [0,T] \times [S_{min}, S_{max}]$ :

$$
\begin{cases}
\frac{\partial v}{\partial t}
+ \frac{1}{2} \sigma^2 s^2 \frac{\partial^2 v}{\partial s^2}
+ r s \frac{\partial v}{\partial s}
- r v = 0, \quad (t,s) \in \Omega, \\
v(T,s) = \phi(s) = \max(K - s, 0),
\quad s \in [S_{\min}, S_{\max}], \\
v(t,S_{\min}) = K e^{-r(T - t)} - S_{\min},
\quad t \in (0,T), \\
v(t,S_{\max}) = 0,
\quad t \in (0,T).
\end{cases}
$$

Nous consid√©rons la grille discr√®te suivante : $h = \frac{S_{max} - S_{min}}{J + 1}$ et $\Delta t = \frac{T}{N}$, avec $J$ et $N$ des entiers positifs, et :
- $s_j = S_{min} + j h$, pour $j = 0, \ldots, J + 1$,
- $t_n = n \Delta t$, pour $n = 0, \ldots, N$.

On cherche une approximation $U_j^n \approx v(t_n, s_j)$ pour $j = 1, \ldots, J$ et $n = 0, \ldots, N$.

Les sch√©mas aux diff√©rences finies nous permettront de discr√©tiser l'√©quation de Black-Scholes du prix d'un put europ√©en sur cette grille.
Dans ce TP, nous consid√©rons divers $\theta$-sch√©mas num√©riques pour ce probl√®me: Le sch√©ma d'Euler explicite, puis Euler implicite, et enfin de Crank-Nicolson.  On √©tudie l'erreur de consistance pour ces sch√©mas. Ces sch√©mas conduisent √† des relations de r√©currence dans $\mathbb{R}^n$, chaque pas consistant √©ventuellement √† r√©soudre un syst√®me lin√©aire dans le cas des sch√©mas implicites.

On √©tudie enfin la convergence de ces $\theta$-sch√©mas. On verra appara√Ætre la notion de stabilit√© conditionnelle (et de condition CFL) pour certains sch√©mas tels que le sch√©ma d'Euler Explicite, et la notion de stabilit√© inconditionnelle pour d'autres sch√©mas tels que le sch√©ma d'Euler Implicite ou de Crank-Nicolson.

# M√©thodes num√©riques

## Sch√©ma d'Euler explicite (EE)

Le sch√©ma d'Euler explicite est un sch√©ma bas√© sur une discr√©tisation explicite en temps. La discr√©tisation de l'EDP est bas√©e sur des approximations centr√©es. D√®s lors, on approxime les d√©riv√©es partielles de la mani√®re suivante :

$$
\begin{cases}
\frac{U_j^{n+1} - U_j^n}{\Delta t} + \frac{1}{2} \sigma^2 s_j^2 \frac{U_{j+1}^n - 2 U_j^n + U_{j-1}^n}{h^2} + r s_j \frac{U_{j+1}^n - U_{j-1}^n}{2 h} - r U_j^n = 0, \quad j = 1, \ldots, J,\quad n = 0, \ldots, N-1. \\
U_j^0 = \phi(s_j), \quad j = 1, \ldots, J. \\
U_0^n = K e^{-r(T - t_n)} - S_{min}, \quad n = 0, \ldots, N. \\
U_{J+1}^n = 0, \quad n = 0, \ldots, N.
\end{cases}
$$

On peut la r√©√©crire sous la forme matricielle afin d'extraire une solution num√©rique dite explicite :
Sous forme matricielle, le sch√©ma s'√©crit :

$$
\begin{array}{l}
\frac{U^{n+1} - A U^n}{\Delta t} +  A U^n + q(t_n) = 0, \quad n = 0, \ldots, N-1, \\
U^0 = (\phi(s_i))_{1 \leq i \leq J},
\end{array}
$$

o√π

-   $A$ est une matrice carr√©e tridiagonale de taille $J \times J$.
    En posant $\alpha_j = \frac{\sigma^2}{2} \frac{s_j^2}{h^2}$ et $\beta_j = r \frac{s_j}{2 h}$, les coefficients de la matrice $A$ sont donn√©s par :

    $$
    \begin{cases}
    A_{j,j-1} = -\alpha_j + \beta_j, \quad j= 2, \ldots, J, \\
    A_{j,j} = 2\alpha_j + r, \quad j = 1, \ldots, J, \\
    A_{j,j+1} = -\alpha_j - \beta_j, \quad j = 1, \ldots, J.
    \end{cases}
    $$

-   $q(t_n)$ un vecteur de $\mathbb{R}^J$ qui d√©pendent des param√®tres du mod√®le et de la discr√©tisation spatiale donn√© par :

    $$
    q_j(t_n) =
    \begin{cases}
    (-\alpha_1 + \beta_1) U_0^n, \quad j = 1, \\
    0, \quad j = 2, \ldots, J-1, \\
    (-\alpha_J + \beta_J) U_{J+1}^n, \quad j = J.
    \end{cases}
    $$

De fait, on obtient la relation de r√©currence explicite permettant de calculer $U^{n+1}$ en fonction de $U^n$ :

$$
U^{n+1} = A U^n - \Delta t ( A U^n + q(t_n) ), \quad n = 0, \ldots, N-1,
$$

## Sch√©ma d'Euler implicite (EI)
Le sch√©ma d'Euler implicite est un sch√©ma bas√© sur une discr√©tisation implicite en temps. La discr√©tisation de l'EDP est bas√©e sur des approximations centr√©es. D√®s lors, on approxime les d√©riv√©es partielles de la mani√®re suivante :

$$\begin{cases}
\frac{U_j^{n+1} - U_j^n}{\Delta t} + \frac{1}{2} \sigma^2 s_j^2 \mathbf{\frac{U_{j+1}^{n+1} - 2 U_j^{n+1} + U_{j-1}^{n+1}}{h^2} + r s_j \frac{U_{j+1}^{n+1} - U_{j-1}^{n+1}}{2 h} - r U_j^{n+1}} = 0, \quad j = 1, \ldots, J,\quad n = 0, \ldots, N-1. \\
U_j^0 = \phi(s_j), \quad j = 1, \ldots, J. \\  
U_0^n = K e^{-r(T - t_n)} - S_{min}, \quad n = 0, \ldots, N. \\
U_{J+1}^n = 0, \quad n = 0, \ldots, N.
\end{cases}
$$

Dans ce cas, la relation de r√©currence s'√©crit sous la forme matricielle suivante :

$$
\begin{array}{l}
\frac{U^{n+1} - A U^n}{\Delta t} +  A U^{n+1} + q(t_{n+1}) = 0, \quad n = 0, \ldots, N-1, \\
U^0 = (\phi(s_i))_{1 \leq i \leq J},
\end{array}
$$

o√π $A$ et $q(t_n)$ sont d√©finis comme pr√©c√©demment.
On obtient ainsi la relation de r√©currence implicite suivante :

$$
( I + \Delta t A ) U^{n+1} = U^n - \Delta t q(t_{n+1}), \quad n = 0, \ldots, N-1,
$$
o√π $I$ est la matrice identit√© de taille $J \times J$.  

## Sch√©ma de Crank-Nicolson (CN)
Le sch√©ma de Crank-Nicolson est un sch√©ma bas√© sur une discr√©tisation implicite en temps. La discr√©tisation de l'EDP est bas√©e sur des approximations centr√©es. D√®s lors, on approxime les d√©riv√©es partielles de la mani√®re suivante :

$$
\begin{cases}
\frac{U_j^{n+1} - U_j^n}{\Delta t} + \frac{1}{2} \left( - \sigma^2 s_j^2 \frac{U_{j+1}^{n+1} - 2 U_j^{n+1} + U_{j-1}^{n+1}}{h^2}  - r s_j \frac{U_{j+1}^{n+1} - U_{j-1}^{n+1}}{2 h} + r U_j^{n+1} \right. \\
\quad + \frac{1}{2} \left( - \sigma^2 s_j^2 \frac{U_{j+1}^n - 2 U_j^n + U_{j-1}^n}{h^2} - r s_j \frac{U_{j+1}^n - U_{j-1}^n}{2 h} + r U_j^n \right) = 0, \quad j = 1, \ldots, J,\quad n = 0, \ldots, N-1. \\
U_j^0 = \phi(s_j), \quad j = 1, \ldots, J. \\
U_0^n = K e^{-r(T - t_n)} - S_{min}, \quad n = 0, \ldots, N. \\
U_{J+1}^n = 0, \quad n = 0, \ldots, N.
\end{cases}
$$

La relation de r√©currence s'√©crit sous la forme matricielle suivante :
$$
\begin{array}{l}
\frac{U^{n+1} - A U^n}{\Delta t} +  \frac{1}{2} A ( U^{n+1} + U^n ) + \frac{1}{2} ( q(t_{n+1}) + q(t_n) ) = 0, \quad n = 0, \ldots, N-1, \\
U^0 = (\phi(s_i))_{1 \leq i \leq J},
\end{array}
$$
o√π $A$ et $q(t_n)$ sont d√©finis comme pr√©c√©demment.
On obtient ainsi la relation de r√©currence implicite suivante :
$$\left( I + \frac{\Delta t}{2} A \right) U^{n+1} = \left( I - \frac{\Delta t}{2} A \right) U^n - \frac{\Delta t}{2} ( q(t_{n+1}) + q(t_n) ), \quad n = 0, \ldots, N-1,
$$
o√π $I$ est la matrice identit√© de taille $J \times J$.


## Choix d'impl√©mentations

Puisque les sch√©mas impl√©ment√©s partagent de nombreuses caract√©ristiques communes, nous d√©finissons une classe de base abstraite `SchemeBase` qui encapsule les param√®tres financiers, la grille discr√®te, les conditions initiales et aux limites, ainsi que la construction de la matrice $A$ et du vecteur $q(t)$. Les sch√©mas sp√©cifiques h√©riteront de cette classe de base et impl√©menteront la m√©thode `solve()` pour r√©soudre le sch√©ma num√©rique particulier.

Trois classes filles seront ensuite d√©finies : `SchemeEE` pour le sch√©ma d'Euler explicite, `SchemeEI` pour le sch√©ma d'Euler implicite, et `SchemeCN` pour le sch√©ma de Crank-Nicolson. Chacune de ces classes impl√©mentera la m√©thode `solve()` en fonction de la nature explicite ou implicite du sch√©ma.

Les codes sont retrouv√©s sur ce lien github [github](https://github.com/cheryl-kdio/EDP-M2MO/tree/main/TP1).


```{python}
# Package imports

import numpy as np
import matplotlib.pyplot as plt
import numpy.linalg as lng
from scipy.sparse import diags,eye
from abc import ABC, abstractmethod
import scipy.stats as stats
from scipy.sparse import csr_matrix as sparse
from scipy.sparse.linalg import spsolve
import pandas as pd
import time
from pprint import pprint
```

```{python}
class SchemeBase(ABC):
    """
    Classe de base pour les sch√©mas num√©riques de l'√©quation de Black-Scholes.
    """
    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):
        # Financial parameters
        self.r = r
        self.sigma = sigma
        self.K = K
        self.T = T

        # Numerical parameters
        self.N = N
        self.J = J
        self.Smin = Smin
        self.Smax = Smax

        # Grids
        self.dt = T / N
        self.h = (Smax - Smin) / (J + 1)
        self.s = Smin + self.h * np.arange(1, J + 1)

        # Operator
        self.A, self.alpha, self.beta = self._build_matrix_A()

    def phi(self, s):
        """
        Condition initiale (payoff) pour un put europ√©en.
        ùúô(s) = max(K - s, 0)
        """
        return np.maximum(self.K - s, 0)

    def uleft(self, t):
        """
        Condition aux limites √† gauche pour un put europ√©en.
        u( t, Smin ) = K * exp(-r * t) - S
        """
        return self.K * np.exp(-self.r * t) - self.Smin

    def uright(self, t):
        """
        Condition aux limites √† droite pour un put europ√©en.
        u( t, Smax ) = 0
        """
        return 0.0

    def _build_matrix_A(self):
        """
        Matrice d'amplification A.
        """
        alpha = 0.5 * self.sigma**2 * (self.s**2 / self.h**2)
        beta  = self.r * self.s / (2 * self.h)

        lower = -alpha[1:] + beta[1:]        # sous-diagonale
        main  = 2 * alpha + self.r            # diagonale principale
        upper = -alpha[:-1] - beta[:-1]       # sur-diagonale

        A = diags(
            diagonals=[lower, main, upper],
            offsets=[-1, 0, 1],
            shape=(self.J, self.J),
            format="csr"
        )

        return A, alpha, beta


    def q(self, t):
        """
        Vecteur des conditions aux limites.
        """
        y = np.zeros(self.J)
        y[0]  = (-self.alpha[0] + self.beta[0]) * self.uleft(t)
        y[-1] = (-self.alpha[-1] - self.beta[-1]) * self.uright(t)
        return y

    def interpolate(self, Sval, U):
        """
        Interpolation lin√©aire pour obtenir la valeur approxim√©e d'un put
        en un point spot Sval donn√©.
        """
        if Sval <= self.Smin:
            return self.uleft(self.T)
        elif Sval >= self.Smax:
            return self.uright(self.T)
        else:
            return np.interp(Sval, self.s, U)

    # Abstract method
    @abstractmethod
    def solve(self):
        """
        M√©thode abstraite de r√©solution du sch√©ma num√©rique.
        """
        raise NotImplementedError("M√©thode solve() √† impl√©menter dans la classe fille")
```

```{python}
class SchemeEE(SchemeBase):
    """
    Sch√©ma d'Euler explicite.
    """
    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):
        super().__init__(r, sigma, K, T, N, J, Smin, Smax)
        self.scheme_name = "Euler Explicite"

    def solve(self):
        """
        R√©solution du sch√©ma d'Euler explicite.
        """
        U = self.phi(self.s)

        for n in range(self.N):
            t = n * self.dt
            U = U - self.dt * (self.A @ U + self.q(t))

        return U,t
```

```{python}
class SchemeEI(SchemeBase):
    """
    Sch√©ma d'Euler implicite.
    """
    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):
        super().__init__(r, sigma, K, T, N, J, Smin, Smax)
        self.scheme_name = "Euler Implicite"

    def solve(self):
        U = self.phi(self.s)
        I = eye(self.J, format="csr")

        for n in range(self.N):
            t = n * self.dt
            U = spsolve(I + self.dt * self.A, U - self.dt * self.q(t))

        return U,t
```

```{python}
class SchemeCN(SchemeBase):
    """
    Sch√©ma de Crank-Nicolson.
    """
    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):
        super().__init__(r, sigma, K, T, N, J, Smin, Smax)
        self.scheme_name = "Crank-Nicolson"

    def solve(self):
        U = self.phi(self.s)
        I = eye(self.J, format="csr")
        factor_minus = I - 0.5 * self.dt * self.A
        factor_plus = I + 0.5 * self.dt * self.A

        for n in range(self.N):
            t = n * self.dt
            U = spsolve(factor_plus, factor_minus@U - self.dt * self.q(t))
        return U,t
```

# R√©sultats des sch√©mas num√©riques

```{python}
r_ = 0.1
sigma_ = 0.2
K_ = 100
T_ = 1
Smin_ = 0
Smax_ = 200
print("Param√®tres financiers:")
print("r=%.2f" %r_, "sigma=%.2f" %sigma_, "K=%.0f" %K_, "T=%.0f" %T_)

# Definition des param√®tres dans un dictionnaire
params = dict(
    r=r_,
    sigma=sigma_,
    K=K_,
    T=T_,
    N=None, # Valeur √† d√©finir plus tard
    J=None, # Valeur √† d√©finir plus tard
    Smin=Smin_,
    Smax=Smax_
)
```

## R√©sultat du sch√©ma d'Euler explicite

Pour √©tudier le comportement du sch√©ma d'Euler explicite, nous avons r√©alis√© des simulations en faisant varier les param√®tres $J$ (nombre de points spatiaux) et $N$ (nombre de points temporels). Nous avons consid√©r√© deux cas distincts :

- Cas 1 : $N$ fix√© √† 10 et $J$ variant parmi les valeurs $\{10, 20, 50\}$.
- Cas 2 : $N$ et $J$ variant simultan√©ment parmi les valeurs $\{10, 20, 50\}$, avec $N = J$.

Les r√©sultats obtenus sont pr√©sent√©s dans les graphiques ci-dessous. Par ailleurs, pour aider √† l'interpr√©tation des r√©sultats, le r√©sultat de la condition de CFL (Courant-Friedrichs-Lewy) est √©galement affich√© sur chaque graphique.

```{python}
# Cas 1 : N = 10, J varie dans `values`

values = [10, 20, 50]
N_fixed = 10

cfl_records1 = []

fig, axes = plt.subplots(1, 3, figsize=(24, 8), sharey=False)
for j, J_ in enumerate(values):
    params['N'] = N_fixed
    params['J'] = J_

    ee = SchemeEE(**params)
    U, t = ee.solve()
    s = ee.s
    dt = ee.dt

    #CFL condition
    CFL = dt / (ee.h ** 2) * (ee.sigma ** 2) * (ee.Smax ** 2)

    # Enregistrement dans la table
    cfl_records1.append({
        "N": N_fixed,
        "J": J_,
        "CFL": CFL
    })

    ax = axes[j]
    ax.plot(s, U, label="Prix option")
    ax.plot(s, ee.phi(s), 'k--', label="Payoff")

    ax.set_title(f"N = {N_fixed}, J = {J_}")
    ax.set_xlabel("s")
    if j == 0:
        ax.set_ylabel("u(t,s)")
    ax.legend()

plt.suptitle(
    f"Evolution du prix du put europ√©en -- Scheme {ee.scheme_name}, N fix√© √† {N_fixed}",
    fontsize=16
)
plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()
```

```{python}

# Cas 2 : N = J avec N, J dans `values`
values = [10, 20, 50]
cfl_records2 = []

fig, axes = plt.subplots(1, 3, figsize=(24, 8), sharey=False)
for j, N_ in enumerate(values):
    params['N'] = N_
    params['J'] = N_

    ee = SchemeEE(**params)
    U, t = ee.solve()
    s = ee.s
    dt = ee.dt

    #CFL condition
    CFL = dt / (ee.h ** 2) * (ee.sigma ** 2) * (ee.Smax ** 2)

    cfl_records2.append({
        "N": N_,
        "J": N_,
        "CFL": CFL
    })

    ax = axes[j]
    ax.plot(s, U, label="Prix option")
    ax.plot(s, ee.phi(s), 'k--', label="Payoff")

    ax.set_title(f"N = J = {N_}, CFL={CFL:.2f}")
    ax.set_xlabel("s")
    if j == 0:
        ax.set_ylabel("u(t,s)")
    ax.legend()

plt.suptitle(
    f"Evolution du prix du put europ√©en -- Scheme {ee.scheme_name}, N = J",
    fontsize=16
)
plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()
```

En analysant les graphiques ci-dessus, nous constatons que le choix de $J$ et $N$, i.e. le maillage spatial et temporel, influence la stabilit√© de l'approximation du prix du put europ√©en.

Dans le cas 1, avec $N$ fix√© √† 10 et $J$ variant, nous constatons que l'approximation de prix est tr√®s proche du prix du put europ√©en pour N=J=10, ce qui est attendu pour un sch√©ma stable.
Cependant, lorsque $J$ augmente, des oscillations apparaissent dans la solution num√©rique, indiquant une instabilit√© du sch√©ma.

Par ailleurs, dans le cas 2, o√π $N$ et $J$ varient simultan√©ment avec $N=J$, nous observons √©galement des oscillations et des instabilit√©s pour des valeurs plus √©lev√©es de $N$ et $J$. Ce comportement instable est similaire √† celui observ√© dans le cas 1, lorsque $J$ augmente pour un $N$ fix√©.

Ces oscillations et instabilit√©s observ√©es dans les deux cas √©tudi√©s sont caract√©ristiques des sch√©mas explicites lorsqu'ils ne respectent pas la condition de stabilit√© requise, dite condition CFL.
En effet,le sch√©ma d'euler explicite est stable conditionnellement au respect de la condition CFL d√©pendant du rapport entre $\Delta t$ et $h^2$.

La condition CFL qui, pour le sch√©ma explicite appliqu√© √† l'√©quation de Black-Scholes, peut √™tre exprim√©e comme suit : $\frac{\Delta t}{h^2} \leq \frac{1}{2 \sigma^2 Smax^2}$.Cette condition impose une relation entre le pas de temps $\Delta t$ et le pas d'espace h. De fait, lorsque J augmente et N diminue, cette condition de stabilit√© peut √™tre viol√©e. Dans notre cas, lorsque J=50 et N=10 ou N=50, la condition CFL n'est pas respect√©e comme on peut l'observer dans le tableau ci-dessous, ce qui explique les oscillations et l'instabilit√© observ√©es dans les r√©sultats num√©riques.

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 143}
cfl_df1 = pd.DataFrame(cfl_records1)  # Cas 1 : N fix√©
cfl_df2 = pd.DataFrame(cfl_records2)  # Cas 2 : N = J

cfl_df1 = cfl_df1.rename(columns={"CFL": "CFL (N=10)"})
cfl_df2 = cfl_df2.rename(columns={"CFL": "CFL (N=J)"})

cfl_table = pd.merge(
    cfl_df1[["J", "CFL (N=10)"]],
    cfl_df2[["J", "CFL (N=J)"]],
    on="J",
    how="inner"
)

cfl_table
```


Pour mieux comprendre l'origine des oscillations, nous avons √©tudi√© la matrice d'amplification du sch√©ma explicite pour N=10 et J=50. La matrice d'amplification est d√©finie par $B:= I - dt*A$ o√π A est la matrice tridiagonale associ√©e au sch√©ma implicite. En calculant les valeurs propres de cette matrice, nous pouvons analyser la stabilit√© du sch√©ma.

En effet, cette matrice intervient dans l'√©volution de la solution num√©rique √† chaque pas de temps, et on a :
$$
||U^n||_2 <= ||B||^n ||U^0||_2, \quad \forall n \geq 0.$$

Si la norme de B est sup√©rieure √† 1, alors les valeurs prises par la solution num√©rique peuvent cro√Ætre de mani√®re exponentielle par rapport √† la condition initiale, conduisant √† des erreurs d'approximation possiblement importantes, des oscillations et ainsi une instabilit√© dans la solution num√©rique.
Pour savoir si la norme de B est sup√©rieure √† 1, nous avons calcul√© le spectre de B et constat√© que la valeur absolue de la plus grande valeur propre d√©passe 1. Cela confirme que le sch√©ma explicite est instable pour les param√®tres choisis, ce qui explique les oscillations observ√©es dans les r√©sultats num√©riques.

Pour cette raison, nous avons test√© d'autres sch√©mas num√©riques tels que le sch√©ma d'Euler implicite et le sch√©ma de Crank-Nicolson, qui sont connus pour leur stabilit√© inconditionnelle.

```{python}
# Param√®tres
params['N'] = 10
params['J'] = 50

ee = SchemeEE(**params)
ee.solve()

# Matrice d'amplification
A = ee.A.toarray()
B = np.eye(ee.J) - ee.dt * A

# Valeurs propres
eigenvalues = lng.eigvals(B)
spectral_radius = np.max(np.abs(eigenvalues))
norm_B = lng.norm(B, 2)

# Tableau r√©capitulatif
df_spectrum = pd.DataFrame({
    "Valeur propre": eigenvalues,
    "|Valeur propre|": np.abs(eigenvalues)
}).sort_values("|Valeur propre|", ascending=False)

# Affichage
print("=== Analyse de stabilit√© du sch√©ma explicite ===\n")

print("Param√®tres num√©riques :")
print(f"  N = {ee.N},  J = {ee.J},  dt = {ee.dt:.2f},  h  = {ee.h:.2f}\n")

print("10 plus grandes valeurs propres de B (tri√©es par module d√©croissant) :")
print(df_spectrum.head(10).to_string(index=False))

print("Norme matricielle induite (norme 2) :")
print(f"  ||B||‚ÇÇ = {norm_B:.6f}\n")

```

## R√©sultat du sch√©ma d'Euler implicite et de Crank-Nicolson

### Cas du sch√©ma d'Euler implicite

Pour √©tudier le comportement du sch√©ma d'Euler implicite, nous nous sommes directement plac√©s dans le cas o√π N=10 et J=50, qui avait montr√© des oscillations dans le sch√©ma explicite. Les r√©sultats obtenus sont pr√©sent√©s dans le graphique ci-dessous. Comme on peut le constater, le sch√©ma d'Euler implicite produit une approximation stable et sans oscillations du prix du put europ√©en, m√™me pour des valeurs √©lev√©es de N et J. Cela confirme la stabilit√© inconditionnelle du sch√©ma implicite, qui ne d√©pend pas de la relation entre le pas de temps et le pas spot.

```{python}
params['J'] = 50
params['N'] = 10

print("Param√®tres financiers:")
print("r=%.2f" %r_, "sigma=%.2f" %sigma_, "K=%.0f" %K_, "T=%.0f" %T_)

print("Param√®tres num√©riques:")
print("J=%.0f" %params['J'], "N=%.0f" %params['N'])
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 472}
ei = SchemeEI(**params)
U,t = ei.solve()
s = ei.s
dt = ei.dt

plt.figure(figsize=(6, 5))
plt.plot(s,U,label="t=%.2f" %(t+dt))
plt.plot(s,ei.phi(s), 'k--', label="payoff")
plt.xlabel("s")
plt.ylabel("u(t,s)")
plt.title("Evolution du prix du put europ√©en au cours du temps [Euler Implicite]")
plt.legend()
plt.show()
```

### Cas du sch√©ma de Crank-Nicolson

Le sch√©ma de Crank-Nicolson, quant √† lui, est une m√©thode implicite qui combine les avantages des sch√©mas explicites et implicites. Il est bas√© sur une moyenne pond√©r√©e des valeurs aux temps n et n+1, ce qui permet d'obtenir une meilleure pr√©cision temporelle tout en maintenant la stabilit√©. Lors de l'√©tude du sch√©ma de Crank-Nicolson, nous avons √©galement choisi les param√®tres N=10 et J=50. Les r√©sultats obtenus sont pr√©sent√©s dans le graphique ci-dessous. Comme on peut le constater, le sch√©ma de Crank-Nicolson produit √©galement une approximation stable et sans oscillations du prix du put europ√©en, confirmant ainsi sa stabilit√© inconditionnelle.

```{python}
params['J'] = 50
params['N'] = 10

print("Param√®tres financiers:")
print("r=%.2f" %r_, "sigma=%.2f" %sigma_, "K=%.0f" %K_, "T=%.0f" %T_)

print("Param√®tres num√©riques:")
print("J=%.0f" %params['J'], "N=%.0f" %params['N'])
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 472}
cn = SchemeCN(**params)
U,t = cn.solve()
s = cn.s
dt = cn.dt

plt.figure(figsize=(6, 5))
plt.plot(s,U,label="t=%.2f" %(t+dt))
plt.plot(s,cn.phi(s), 'k--', label="payoff")
plt.xlabel("s")
plt.ylabel("u(t,s)")
plt.title("Evolution du prix du put europ√©en au cours du temps [Crank-Nicolson]")
plt.legend()
plt.show()
```

# Compl√©ment 1: Black and Scholes

## M√©thodes

Afin de comparer les r√©sultats num√©riques obtenus avec les diff√©rents $\theta-$sch√©mas au prix th√©orique du put europ√©en, nous avons impl√©ment√© la formule de Black and Scholes dans une fonction Python. Cette fonction calcule le prix du put en utilisant les param√®tres financiers tels que le prix de l'actif sous-jacent, le prix d'exercice, le taux d'int√©r√™t sans risque, la volatilit√© et le temps jusqu'√† l'√©ch√©ance.

Nous analysons la convergence des sch√©mas num√©riques consid√©r√©s, ainsi que les ordres de convergence.
La convergence est ensuite √©tudi√©e num√©riquement en comparant les prix obtenus par les sch√©mas avec la solution analytique du put europ√©en, et les ordres de convergence sont estim√©s √† partir du comportement asymptotique de l‚Äôerreur lorsque les pas de temps et d‚Äôespace tendent vers z√©ro.

Pour estimer num√©riquement l'ordre de convergence des sch√©mas, on utilise la relation $e_k \sim C h_k^\alpha$, o√π $C$ est une constante ind√©pendante de $h_k$ et $\alpha$ est l'ordre de convergence du sch√©ma, $h_k$ √©tant le pas de discr√©tisation spatial, d√©fini par $h_k = \frac{S_{max} - S_{min}}{J_k + 1}$, et $J_k$ le nombre de points spatiaux utilis√©s dans la discr√©tisation. De fait, on obtient l'ordre de convergence $\alpha$ en comparant les erreurs $e_k$ et $e_{k+1}$ pour deux maillages successifs. D'o√π
$$\alpha_k
= \frac{\log\!\left(\frac{e_{k+1}}{e_k}\right)}
       {\log\!\left(\frac{h_{k+1}}{h_k}\right)}.
$$

Nous consid√©rons deux grilles de discr√©tisation successives d√©finies par les couples $(N_k, J_k)$, √† savoir $N=J$ et $N = \frac{J^2}{10}$, avec $J \in \{10, 20, 40, 80, 160\}$.

```{python}
print("Param√®tres financiers:")
Sval = 80
print("r=%.2f" %r_, "sigma=%.2f" %sigma_, "K=%.0f" %K_, "T=%.0f" %T_, "Sval=%.2f" %Sval)
```

```{python}
# Implementation de la formule de Black and Scholes
def dplus(x,K,r,sigma,T,t):
    tau = T-t
    numerator = np.log(x/K) + tau * (r + 0.5*sigma**2)
    denominator = sigma * np.sqrt(tau)
    return numerator / denominator

def dmoins(dplus_,sigma,tau):
    return dplus_ - sigma * np.sqrt(tau)

def compute_BS_price(x,K,r,sigma,T,t=0,type_='call'):
    tau = T-t
    dplus_ = dplus(x,K,r,sigma,T,t)
    dmoins_ = dmoins(dplus_,sigma,tau)
    if type_ == 'call':
        return x*stats.norm.cdf(dplus_) - K * np.exp(-r*tau) * stats.norm.cdf(dmoins_)
    elif type_=='put':
        return K* np.exp(-r*tau)* stats.norm.cdf(-dmoins_) - x * stats.norm.cdf(-dplus_)
```

```{python}
price_BS = compute_BS_price(Sval, params['K'], params['r'], params['sigma'], params['T'], t=0, type_='put')
print("Prix th√©orique du put pour S=%.2f : %.4f" %(Sval, price_BS))
```

```{python}
def get_convergence_table(N_grid, J_grid, params, Sval, scheme_class):

    est_prices = []
    errex = []
    errors = []
    cpu_times = []

    # Prix exact (identique pour tous)
    BS_price = compute_BS_price(
        Sval, params['K'], params['r'],
        params['sigma'], params['T'],
        t=0, type_='put'
    )

    for N, J in zip(N_grid, J_grid):
        params['N'] = N
        params['J'] = J

        start = time.time()
        scheme = scheme_class(**params)
        U, _ = scheme.solve()
        tcpu = time.time() - start

        price_est = scheme.interpolate(Sval, U)

        est_prices.append(price_est)
        errex.append(abs(price_est - BS_price))
        cpu_times.append(tcpu)

    est_prices = np.array(est_prices)
    errors = np.zeros(len(est_prices))
    errors[1:] = np.abs(np.diff(est_prices))
    errex = np.array(errex)
    cpu_times = np.array(cpu_times)

    # Ordre de convergence global
    alpha = np.zeros(len(errors))
    h_step = (params["Smax"] - params["Smin"]) / (J_grid + 1)
    alpha[1:] = np.log(errex[:-1] / errex[1:]) / np.log(h_step[:-1] / h_step[1:])

    df = pd.DataFrame({
        "J": J_grid,
        "N": N_grid,
        "U(s)": est_prices,
        "error": errors,
        "alpha": alpha,
        "errex": errex,
        "tcpu": cpu_times
    })

    return df.round(6)
```

## R√©sultats

<!-- On constate que par rapport au schema d'euler implicite, le schema de Crank-Nicolson offre une meilleure pr√©cision temporelle tout en maintenant la stabilit√©, ce qui le rend particuli√®rement adapt√© pour la r√©solution des EDP en finance.
C'est le sch√©ma qui a par ailleurs l'ordre de convergence le plus √©lev√© parmi les deux sch√©mas √©tudi√©s. -->

On constate que les trois sch√©mas pr√©sentent des comportements tr√®s contrast√©s en termes de stabilit√©, ordre de convergence et co√ªt de calcul lorsque l‚Äôon impose $N = J$.

On observe tout d‚Äôabord que le sch√©ma d‚ÄôEuler explicite ne peut pas √™tre consid√©r√© comme fiable dans ce cadre, comme pr√©cis√© pr√©c√©demment.
Pour des maillages grossiers, l‚Äôerreur semble initialement d√©cro√Ætre et l‚Äôordre estim√© est proche de 2, ce qui pourrait sugg√©rer une bonne convergence. Cependant, d√®s que la discr√©tisation devient plus fine, la solution diverge et on observe une explosion num√©rique √† partir de $N = J = 80$ qui montre clairement que la condition de stabilit√© n‚Äôest plus satisfaite lorsque $\Delta t$ et $\Delta s$ sont raffin√©s simultan√©ment.

Le sch√©ma d‚ÄôEuler implicite est parfaitement stable sur toute la plage de discr√©tisations consid√©r√©e. L‚Äôerreur d√©cro√Æt de fa√ßon r√©guli√®re lorsque $N = J$ augmente, sans aucune instabilit√© num√©rique. De plus, l‚Äôordre de convergence estim√© reste inf√©rieur √† 2 et tend progressivement vers une valeur proche de 1, ce qui est coh√©rent avec le fait que, lorsque $\Delta t \sim \Delta s$, l‚Äôerreur temporelle d‚Äôordre 1 domine l‚Äôerreur spatiale.

Enfin, on constate que le sch√©ma de Crank‚ÄìNicolson pr√©sente le comportement le plus satisfaisant. Il est stable sur toute la grille, l‚Äôerreur d√©cro√Æt rapidement et l‚Äôordre de convergence estim√© est tr√®s proche de 2 d√®s les maillages interm√©diaires, puis se stabilise autour de cette valeur pour les maillages fins. Ce r√©sultat est parfaitement conforme √† la th√©orie, puisque le sch√©ma est d‚Äôordre 2 √† la fois en temps et en espace.

Pour conclure, lorsque $N = J$, en termes de temps de calcul, le sch√©ma EE est certes le plus rapide sur les grilles grossi√®res, avec des temps de simulation de l‚Äôordre de la milliseconde, mais cet avantage est sans int√©r√™t pratique puisque la solution devient totalement inutilisable pour des maillages fins.
Le sch√©ma implicite constitue une solution robuste mais relativement co√ªteuse et moins pr√©cise. En effet, il n√©cessite la r√©solution d‚Äôun syst√®me lin√©aire √† chaque pas de temps. Cela se refl√®te clairement dans les temps de calcul, qui augmentent sensiblement avec le raffinement et deviennent significatifs pour les maillages fins, atteignant plus de 0.1 seconde pour $N = J = 160$.

Le sch√©ma de Crank‚ÄìNicolson appara√Æt comme le meilleur compromis, combinant stabilit√©, convergence d‚Äôordre 2 et temps de calcul raisonnables.
En termes de co√ªt de calcul, le sch√©ma CN est plus cher que le sch√©ma explicite mais reste nettement plus efficace que le sch√©ma implicite pur. Les temps de simulation restent mod√©r√©s, m√™me pour des valeurs √©lev√©es de $N = J$, et demeurent largement compatibles avec une utilisation pratique, tout en offrant une pr√©cision bien sup√©rieure.

```{python}
N_grid = J_grid = np.array([10, 20, 40, 80, 160])
print("Cas N = J\n", "="*75)

print("Convergence Table for Scheme EE:")
print(get_convergence_table(N_grid, J_grid, params, Sval, SchemeEE))

print("="*75, "\nConvergence Table for Scheme EI:")
print(get_convergence_table(N_grid, J_grid, params, Sval, SchemeEI))

print("="*75, "\nConvergence Table for Scheme CN:")
print(get_convergence_table(N_grid, J_grid, params, Sval, SchemeCN))
```

<!-- Avec $N = \frac{J^2}{10}$, on constate que le sch√©ma explicite respecte la condition de stabilit√© de CFL, ce qui garantit la stabilit√© num√©rique de la solution. En revanche, lorsque $N = J$, la condition de CFL n'est pas respect√©e, ce qui peut entra√Æner des instabilit√©s dans la solution num√©rique.
Par ailleurs, les ordres de convergence obtenus dans les deux cas sont similaires, ce qui sugg√®re que le choix de la relation entre $N$ et $J$ n'affecte pas significativement la pr√©cision du sch√©ma dans ce contexte particulier.
De m√™me, nous avons des erreurs similaires pour les deux relations entre N et J, ce qui indique que le sch√©ma de Crank-Nicolson est robuste par rapport √† ces choix de maillage temporel et spatial. -->

On constate que le choix $N = J^2/10$ modifie l‚Äôanalyse par rapport au cas $N = J$, en particulier pour le sch√©ma explicite. Alors que ce dernier √©tait instable lorsque les pas de temps et d‚Äôespace √©taient raffin√©s simultan√©ment, il devient ici parfaitement stable. L‚Äôerreur d√©cro√Æt r√©guli√®rement et l‚Äôordre de convergence est tr√®s proche de 2 sur l‚Äôensemble des maillages, ce qui montre que la condition de stabilit√© est d√©sormais respect√©e et que l‚Äôerreur spatiale domine. Le sch√©ma EE retrouve ainsi une convergence th√©oriquement optimale, tout en conservant un co√ªt de calcul globalement inf√©rieur √† celui des sch√©mas implicites.

Le sch√©ma d‚ÄôEuler implicite reste, comme pr√©c√©demment, inconditionnellement stable. Cependant, contrairement au cas $N = J$, l‚Äôordre de convergence n‚Äôest plus limit√© par l‚Äôerreur temporelle et tend lui aussi vers 2 lorsque $J$ augmente. Cette am√©lioration de la pr√©cision se fait au prix d‚Äôun co√ªt de calcul tr√®s √©lev√©, les temps de simulation augmentant fortement avec $N$, ce qui rend le sch√©ma peu comp√©titif pour des grilles fines.

Le sch√©ma de Crank‚ÄìNicolson conserve un comportement tr√®s r√©gulier et conforme √† la th√©orie. Il est stable, pr√©sente une convergence d‚Äôordre 2 et offre des erreurs comparables √† celles du sch√©ma explicite stabilis√©. En revanche, son co√ªt de calcul augmente sensiblement avec le raffinement et devient proche de celui du sch√©ma implicite pour les maillages les plus fins.

Ainsi, contrairement au cas $N = J$ o√π Crank‚ÄìNicolson apparaissait clairement comme le meilleur compromis, le r√©gime $N = J^2/10$ met en √©vidence l‚Äôefficacit√© du sch√©ma explicite, qui combine ici stabilit√©, convergence d‚Äôordre 2 et temps de calcul plus faibles, √† condition d‚Äôaccepter une contrainte forte sur le pas de temps.

```{python}
N_grid = np.array([(j**2)/10 for j in J_grid]).astype(int)

print("Cas N = J^2/10\n", "="*75)
print("Convergence Table for Scheme EE:")
print(get_convergence_table(N_grid, J_grid, params, Sval, SchemeEE))

print("="*75, "\nConvergence Table for Scheme EI:")
print(get_convergence_table(N_grid, J_grid, params, Sval, SchemeEI))

print("="*75, "\nConvergence Table for Scheme CN:")
print(get_convergence_table(N_grid, J_grid, params, Sval, SchemeCN))
```

# Compl√©ment 2 : Call option

Dans ce compl√©ment, nous √©tendons l‚Äô√©tude pr√©c√©dente au cas de l‚Äôoption call europ√©enne, en adaptant les conditions initiales et aux limites du probl√®me de Black‚ÄìScholes. La structure des sch√©mas num√©riques aux diff√©rences finies (Euler explicite, Euler implicite et Crank‚ÄìNicolson) reste inchang√©e, seule la nature du payoff et des conditions aux fronti√®res √©tant modifi√©e. Notre objectif est de v√©rifier que les propri√©t√©s observ√©es pr√©c√©demment pour le put europ√©en (en particulier en termes de stabilit√© et de convergence) se retrouvent √©galement dans le cas du call. Les r√©sultats num√©riques obtenus et pr√©sent√©s ci apr√®s permettent de confirmer la robustesse des sch√©mas √©tudi√©s vis-√†-vis du type d‚Äôoption consid√©r√©e.

## Choix d'impl√©mentations

L‚Äôimpl√©mentation des sch√©mas num√©riques est rest√©e globalement inchang√©e par rapport au cas du put europ√©en. La m√™me classe de base SchemeBase est utilis√©e pour d√©finir la grille de discr√©tisation et les op√©rateurs num√©riques, tandis que seules la condition initiale, correspondant au payoff du call europ√©en, ainsi que les conditions aux limites ont √©t√© adapt√©es. Les sch√©mas d‚ÄôEuler explicite, d‚ÄôEuler implicite et de Crank‚ÄìNicolson sont impl√©ment√©s de mani√®re identique via les classes SchemeEE, SchemeEI et SchemeCN.

```{python}
class SchemeBase(ABC):
    """
    Classe de base pour les sch√©mas num√©riques de l'√©quation de Black-Scholes.
    """
    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):
        # Financial parameters
        self.r = r
        self.sigma = sigma
        self.K = K
        self.T = T

        # Numerical parameters
        self.N = N
        self.J = J
        self.Smin = Smin
        self.Smax = Smax

        # Grids
        self.dt = T / N
        self.h = (Smax - Smin) / (J + 1)
        self.s = Smin + self.h * np.arange(1, J + 1)

        # Operator
        self.A, self.alpha, self.beta = self._build_matrix_A()

    def phi(self, s):
        """
        Condition initiale (payoff) pour un call europ√©en.
        ùúô(s) = max(s - K, 0)
        """
        return np.maximum(s-self.K, 0)

    def uleft(self, t):
        """
        Condition aux limites √† gauche pour un call europ√©en.
        """
        return 0.0

    def uright(self, t):
        """
        Condition aux limites √† droite pour un put europ√©en.
        """
        return self.Smax - self.K * np.exp(-self.r * t)

    def _build_matrix_A(self):
        """
        Matrice d'amplification A.
        """
        alpha = 0.5 * self.sigma**2 * (self.s**2 / self.h**2)
        beta  = self.r * self.s / (2 * self.h)

        lower = -alpha[1:] + beta[1:]        # sous-diagonale
        main  = 2 * alpha + self.r            # diagonale principale
        upper = -alpha[:-1] - beta[:-1]       # sur-diagonale

        A = diags(
            diagonals=[lower, main, upper],
            offsets=[-1, 0, 1],
            shape=(self.J, self.J),
            format="csr"
        )

        return A, alpha, beta

    def q(self, t):
        """
        Vecteur des conditions aux limites.
        """
        y = np.zeros(self.J)
        y[0]  = (-self.alpha[0] + self.beta[0]) * self.uleft(t)
        y[-1] = (-self.alpha[-1] - self.beta[-1]) * self.uright(t)
        return y

    def interpolate(self, Sval, U):
        """
        Interpolation lin√©aire pour obtenir la valeur approxim√©e d'un put
        en un point spot Sval donn√©.
        """
        if Sval <= self.Smin:
            return self.uleft(self.T)
        elif Sval >= self.Smax:
            return self.uright(self.T)
        else:
            return np.interp(Sval, self.s, U)

    # Abstract method
    @abstractmethod
    def solve(self):
        """
        M√©thode abstraite de r√©solution du sch√©ma num√©rique.
        """
        raise NotImplementedError("M√©thode solve() √† impl√©menter dans la classe fille")
```

```{python}
class SchemeEE(SchemeBase):
    """
    Sch√©ma d'Euler explicite.
    """
    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):
        super().__init__(r, sigma, K, T, N, J, Smin, Smax)
        self.scheme_name = "Euler Explicite"

    def solve(self):
        """
        R√©solution du sch√©ma d'Euler explicite.
        """
        U = self.phi(self.s)

        for n in range(self.N):
            t = n * self.dt
            U = U - self.dt * (self.A @ U + self.q(t))

        return U,t
```

```{python}
class SchemeEI(SchemeBase):
    """
    Sch√©ma d'Euler implicite.
    """
    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):
        super().__init__(r, sigma, K, T, N, J, Smin, Smax)
        self.scheme_name = "Euler Implicite"

    def solve(self):
        U = self.phi(self.s)
        I = eye(self.J, format="csr")

        for n in range(self.N):
            t = n * self.dt
            U = spsolve(I + self.dt * self.A, U - self.dt * self.q(t))

        return U,t
```

```{python}
class SchemeCN(SchemeBase):
    """
    Sch√©ma de Crank-Nicolson.
    """
    def __init__(self, r, sigma, K, T, N, J, Smin, Smax):
        super().__init__(r, sigma, K, T, N, J, Smin, Smax)
        self.scheme_name = "Crank-Nicolson"

    def solve(self):
        U = self.phi(self.s)
        I = eye(self.J, format="csr")
        factor_minus = I - 0.5 * self.dt * self.A
        factor_plus = I + 0.5 * self.dt * self.A

        for n in range(self.N):
            t = n * self.dt

            U = spsolve(factor_plus, factor_minus@U - self.dt * self.q(t))
        return U,t
```

## R√©sultats des sch√©mas num√©riques

### Cas du sch√©ma d'Euler explicite

Les r√©sultats pr√©c√©dents ont montr√© que le sch√©ma d‚ÄôEuler explicite est conditionnellement stable en fonction de $J$, $N$ et de la condition CFL. Ici, nous l‚Äôappliquons √† un call europ√©en en utilisant les m√™mes configurations que pour le put :
- (1) $N = 10$ et $J \in {10, 20, 50}$,
- (2) $N = J \in {10, 20, 50}$.

Les r√©sultats, accompagn√©s de l‚Äôindication de la condition CFL, sont pr√©sent√©s dans les graphiques ci‚Äëdessous.

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 394}
# Cas 1 : N = 10, J varie dans `values` pour le call europ√©en
values = [10, 20, 50]
N_fixed = 10
cfl_records1 = []

fig, axes = plt.subplots(1, 3, figsize=(24, 8), sharey=False)
for j, J_ in enumerate(values):
    params['N'] = N_fixed
    params['J'] = J_

    ee = SchemeEE(**params)
    U, t = ee.solve()
    s = ee.s
    dt = ee.dt

    # Condition CFL
    CFL = dt / (ee.h ** 2) * (ee.sigma ** 2) * (ee.Smax ** 2)

    # Enregistrement
    cfl_records1.append({
        "N": N_fixed,
        "J": J_,
        "CFL": CFL
    })

    ax = axes[j]
    ax.plot(s, U, label="Prix option")
    ax.plot(s, ee.phi(s), 'k--', label="Payoff")

    ax.set_title(f"N = {N_fixed}, J = {J_}, CFL={CFL:.2f}")
    ax.set_xlabel("s")
    if j == 0:
        ax.set_ylabel("u(t,s)")
    ax.legend()

plt.suptitle(
    f"Evolution du prix du call europ√©en -- Scheme {ee.scheme_name}, N fix√© √† {N_fixed}",
    fontsize=16
)
plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 394}
#Cas 2 : N = J avec N, J dans `values` pour le call europ√©en
cfl_records2 = []

fig, axes = plt.subplots(1, 3, figsize=(24, 8), sharey=False)
for j, N_ in enumerate(values):
    params['N'] = N_
    params['J'] = N_

    ee = SchemeEE(**params)
    U, t = ee.solve()
    s = ee.s
    dt = ee.dt

    # Condition CFL
    CFL = dt / (ee.h ** 2) * (ee.sigma ** 2) * (ee.Smax ** 2)

    cfl_records2.append({
        "N": N_,
        "J": N_,
        "CFL": CFL
    })

    ax = axes[j]
    ax.plot(s, U, label="Prix option")
    ax.plot(s, ee.phi(s), 'k--', label="Payoff")

    ax.set_title(f"N = J = {N_}, CFL={CFL:.2f}")
    ax.set_xlabel("s")
    if j == 0:
        ax.set_ylabel("u(t,s)")
    ax.legend()

plt.suptitle(
    f"Evolution du prix du call europ√©en -- Scheme {ee.scheme_name}, N = J",
    fontsize=16
)
plt.tight_layout(rect=[0, 0, 1, 0.95])
plt.show()
```

Comme pour le put, le sch√©ma d‚ÄôEuler explicite pour le call est stable pour de petites valeurs de $J$ et $N$, et devient instable lorsque la condition CFL n‚Äôest pas respect√©e, entra√Ænant des oscillations.

### Cas des sch√©mas d'Euler implicite et de Crank-Nicolson




Les sch√©mas d'Euler implicite et de Crank-Nikolson, appliqu√©s au cas du call europ√©en, demeurent inconditionnellement stables. Ils sont test√©s sur la configuration N= 10 et J= 50, qui avait conduit √† des instabilit√©s et √† des oscillations pour le schema explicite. Les r√©sultats obtenus montrent une approximation stable et sans oscillations du prix du call.

```{python}
params['J'] = 50
params['N'] = 10

print("Param√®tres financiers:")
print("r=%.2f" %r_, "sigma=%.2f" %sigma_, "K=%.0f" %K_, "T=%.0f" %T_)

print("Param√®tres num√©riques:")
print("J=%.0f" %params['J'], "N=%.0f" %params['N'])
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 472}
ei = SchemeEI(**params)
U,t = ei.solve()
s = ei.s
dt = ei.dt

plt.figure(figsize=(6, 5))
plt.plot(s,U,label="t=%.2f" %(t+dt))
plt.plot(s,ei.phi(s), 'k--', label="payoff")
plt.xlabel("s")
plt.ylabel("u(t,s)")
plt.title("Evolution du prix du call europ√©en au cours du temps [Euler Implicite]")
plt.legend()
plt.show()
```

```{python}
#| colab: {base_uri: https://localhost:8080/, height: 472}
cn = SchemeCN(**params)
U,t = cn.solve()
s = cn.s
dt = cn.dt

plt.figure(figsize=(6, 5))
plt.plot(s,U,label="t=%.2f" %(t+dt))
plt.plot(s,cn.phi(s), 'k--', label="payoff")
plt.xlabel("s")
plt.ylabel("u(t,s)")
plt.title("Evolution du prix du call europ√©en au cours du temps [Crank-Nicolson]")
plt.legend()
plt.show()
```

