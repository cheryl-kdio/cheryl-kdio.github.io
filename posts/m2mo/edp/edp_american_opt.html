<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Cheryl Kouadio">
<meta name="dcterms.date" content="2026-02-08">
<meta name="description" content="Cheryl Kouadio is a graduate student in stochastic modeling and quantitative finance at Universit√© Paris Cit√©. Her academic interests focus on probability theory, stochastic processes, data analysis, and financial risk modeling. She studies how rigorous statistical and mathematical methods can be applied to quantify uncertainty and support decision-making in finance and risk management.">

<title>Finite difference Methods for American Options ‚Äì Cheryl Kouadio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-3146a0984a964146c28da0a2cf78b9ad.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

<!-- 
Load Academicons v1: https://jpswalsh.github.io/academicons/
-->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">

<link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">


<!---
The following code are needed to show dimension citation and altmetrics.
https://api.altmetric.com/embeds.html
https://badge.dimensions.ai/
--->

<script type="text/javascript" src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>

<script async="" src="https://badge.dimensions.ai/badge.js" charset="utf-8"></script>

<script type="text/javascript" src="//cdn.plu.mx/widget-popup.js"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
<meta property="og:title" content="Finite difference Methods for American Options ‚Äì Cheryl Kouadio">
<meta property="og:description" content="EDP in finance">
<meta property="og:image" content="https://cheryl-kdio.github.io/posts/m2mo/edp/edp_american_opt_files/figure-html/cell-11-output-1.png">
<meta property="og:site_name" content="Cheryl Kouadio">
<meta property="og:image:height" content="757">
<meta property="og:image:width" content="2294">
<meta name="twitter:title" content="Finite difference Methods for American Options ‚Äì Cheryl Kouadio">
<meta name="twitter:description" content="EDP in finance">
<meta name="twitter:image" content="https://cheryl-kdio.github.io/posts/m2mo/edp/edp_american_opt_files/figure-html/cell-11-output-1.png">
<meta name="twitter:image-height" content="757">
<meta name="twitter:image-width" content="2294">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Cheryl Kouadio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-about" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">About</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-about">    
        <li>
    <a class="dropdown-item" href="../../../posts.html#category=news">
 <span class="dropdown-text">News</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../posts.html#category=event">
 <span class="dropdown-text">Events</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../now.html">
 <span class="dropdown-text">Now</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-articles" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Articles</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-articles">    
        <li>
    <a class="dropdown-item" href="../../../publications.html">
 <span class="dropdown-text">Reports</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../posts.html#category=paper">
 <span class="dropdown-text">All papers</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../posts.html#category=ensai-gdr">
 <span class="dropdown-text">Ensai</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../posts.html#category=m2mo">
 <span class="dropdown-text">M2MO</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-outreach" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Outreach</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-outreach">    
        <li>
    <a class="dropdown-item" href="../../../posts.html#category=outreach">
 <span class="dropdown-text">Policy Engagement</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../posts.html#category=presentation">
 <span class="dropdown-text">Presentations</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../../notes.html">
 <span class="dropdown-text">Notes</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../../glossary.html"> 
<span class="menu-text">Glossary</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../files/Cheryl-Kouadio-CV.pdf" target="_blank"> 
<span class="menu-text">CV</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/cheryl-kdio" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text">Github</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.linkedin.com/in/cheryl-kouadio-251815206/" target="_blank"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text">Linkedin</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../../posts.xml" target="_blank"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#m√©thodes-num√©riques" id="toc-m√©thodes-num√©riques" class="nav-link active" data-scroll-target="#m√©thodes-num√©riques">M√©thodes num√©riques</a>
  <ul class="collapse">
  <li><a href="#explicit-euler-scheme-or-euler-forward-scheme" id="toc-explicit-euler-scheme-or-euler-forward-scheme" class="nav-link" data-scroll-target="#explicit-euler-scheme-or-euler-forward-scheme">Explicit Euler Scheme or Euler Forward Scheme</a></li>
  <li><a href="#implicit-euler-scheme" id="toc-implicit-euler-scheme" class="nav-link" data-scroll-target="#implicit-euler-scheme">Implicit Euler Scheme</a>
  <ul class="collapse">
  <li><a href="#splitting-scheme" id="toc-splitting-scheme" class="nav-link" data-scroll-target="#splitting-scheme">Splitting scheme</a></li>
  <li><a href="#m√©thodes-num√©riques-de-r√©solution" id="toc-m√©thodes-num√©riques-de-r√©solution" class="nav-link" data-scroll-target="#m√©thodes-num√©riques-de-r√©solution">M√©thodes num√©riques de r√©solution</a></li>
  </ul></li>
  <li><a href="#higher-order-schemes" id="toc-higher-order-schemes" class="nav-link" data-scroll-target="#higher-order-schemes">Higher order schemes</a></li>
  </ul></li>
  <li><a href="#impl√©mentations" id="toc-impl√©mentations" class="nav-link" data-scroll-target="#impl√©mentations">Impl√©mentations</a></li>
  <li><a href="#r√©sultats-des-sch√©mas-num√©riques" id="toc-r√©sultats-des-sch√©mas-num√©riques" class="nav-link" data-scroll-target="#r√©sultats-des-sch√©mas-num√©riques">R√©sultats des sch√©mas num√©riques</a>
  <ul class="collapse">
  <li><a href="#euler-explicit-scheme" id="toc-euler-explicit-scheme" class="nav-link" data-scroll-target="#euler-explicit-scheme">Euler Explicit Scheme</a></li>
  <li><a href="#schemas-implicites" id="toc-schemas-implicites" class="nav-link" data-scroll-target="#schemas-implicites">Schemas implicites</a>
  <ul class="collapse">
  <li><a href="#splitting-euler-implicit-scheme-splitting-crank-nicolson-scheme" id="toc-splitting-euler-implicit-scheme-splitting-crank-nicolson-scheme" class="nav-link" data-scroll-target="#splitting-euler-implicit-scheme-splitting-crank-nicolson-scheme">Splitting Euler Implicit scheme &amp; Splitting Crank-Nicolson Scheme</a></li>
  <li><a href="#psor-algorithm-1" id="toc-psor-algorithm-1" class="nav-link" data-scroll-target="#psor-algorithm-1">PSOR Algorithm</a></li>
  <li><a href="#semi-smooth-newtons-method-1" id="toc-semi-smooth-newtons-method-1" class="nav-link" data-scroll-target="#semi-smooth-newtons-method-1">Semi-smooth Newton‚Äôs method</a></li>
  <li><a href="#mini-conclusion-sur-les-sch√©ma-implicites" id="toc-mini-conclusion-sur-les-sch√©ma-implicites" class="nav-link" data-scroll-target="#mini-conclusion-sur-les-sch√©ma-implicites">Mini-conclusion sur les sch√©ma implicites</a></li>
  </ul></li>
  <li><a href="#higher-order-schemes-1" id="toc-higher-order-schemes-1" class="nav-link" data-scroll-target="#higher-order-schemes-1">Higher order schemes</a>
  <ul class="collapse">
  <li><a href="#bdf-scheme" id="toc-bdf-scheme" class="nav-link" data-scroll-target="#bdf-scheme">BDF Scheme</a></li>
  </ul></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Finite difference Methods for American Options</h1>
<p class="subtitle lead">EDP in finance</p>
  <div class="quarto-categories">
    <div class="quarto-category">paper</div>
    <div class="quarto-category">m2mo</div>
    <div class="quarto-category">edp</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Authors</div>
    <div class="quarto-title-meta-contents">
             <p>Cheryl KOUADIO </p>
             <p>Marilene Kougoum </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">February 8, 2026</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Dans ce TP, on √©tudie des sch√©mas num√©riques permettant d‚Äôapprocher la solution de l‚Äô√©quation de Black-Scholes pour les options am√©ricaines. On considerera en particulier deux cas de payoff pour les options am√©ricaines :</p>
<ul>
<li><p><strong>payoff 1:</strong> le cas de put standard de payoff <span class="math inline">\(\phi_1(s) = (K-s)^+\)</span>, avec <span class="math inline">\(K\)</span> le prix d‚Äôexercice de l‚Äôoption. Ce payoff est connu pour avoir de bonnes propri√©t√©s de r√©gularit√©, i.e.&nbsp;il est continu et m√™me lipschitzien, ce qui facilite l‚Äôanalyse num√©rique.</p></li>
<li><p><strong>payoff 2:</strong> le cas d‚Äôun produit de payoff <span class="math inline">\(\phi_2(s) = K \mathbf{1}_{\frac{K}{2} \leq s \leq K }\)</span>, qui correspond √† une option de type ‚Äúcash-or-nothing‚Äù (payoff en cash) avec barri√®re. Ce payoff est plus irr√©gulier, puisqu‚Äôil est discontinu, ce qui rend l‚Äôanalyse num√©rique plus d√©licate.</p></li>
</ul>
<p>Dans les deux cas, l‚ÄôEDP correspond √† un syst√®me non lin√©aire d‚Äô√©quations aux d√©riv√©es partielles suivant : <span class="math display">\[
\begin{cases}
\min \left( \frac{\partial v}{\partial t} - \frac{1}{2} \sigma^2 s^2 \frac{\partial^2 v}{\partial s^2} - r s \frac{\partial v}{\partial s} + r v, v - \phi \right) = 0, \quad (t,s) \in (0,T) \times (S_{min}, S_{max}), \\
v(t, S_{min}) = v_l(t), \quad t \in (0,T), \\
v(t, S_{max}) = v_r(t) := 0, \quad t \in (0,T), \\
v(0,s) = g(s), \quad s \in (S_{min}, S_{max}),
\end{cases}
\]</span></p>
<p>Dans le cas du payoff 1, on a <span class="math inline">\(v_l(t) := \phi(S_{min}) = K - S_{min}\)</span>, tandis que dans le cas du payoff 2, on a <span class="math inline">\(v_l(t) := \phi(S_{min}) = 0\)</span>.</p>
<p>Ces sch√©mas nous permettront d‚Äôobtenir une approximation num√©rique de la fonction de prix d‚Äôun put europ√©en <span class="math inline">\(v(t,s)\)</span>, avec <span class="math inline">\(t \in [0,T]\)</span> et <span class="math inline">\(s \in [S_{min}, S_{max}]\)</span>.</p>
<p>Les sch√©mas num√©riques permettant d‚Äôapprocher cette EDP abord√©s ici sont : 1. le sch√©ma d‚ÄôEuler explicite 2. le sch√©ma d‚ÄôEuler implicite (et plus g√©n√©ralement pour tout sch√©ma implicite pour les options am√©ricaines), on est conduit √† un systeme non lin√©aire discret √† r√©soudre √† chaque pas de temps, qui √† la forme d‚Äôun ‚Äúprobl√®me d‚Äôobstacle‚Äù. 2. On s‚Äôint√©ressera √† diverses m√©thodes num√©riques de r√©solution de ce syst√®me, telles que la m√©thode PSOR (projected successive over-relaxation), une m√©thode de type Newton.</p>
<section id="m√©thodes-num√©riques" class="level1">
<h1>M√©thodes num√©riques</h1>
<p>Nous consid√©rons la grille discr√®te suivante : <span class="math inline">\(h = \frac{S_{max} - S_{min}}{J + 1}\)</span> et <span class="math inline">\(\Delta t = \frac{T}{N}\)</span>, avec <span class="math inline">\(J\)</span> et <span class="math inline">\(N\)</span> des entiers positifs, et : - <span class="math inline">\(s_j = S_{min} + j h\)</span>, pour <span class="math inline">\(j = 0, \ldots, J + 1\)</span>, - <span class="math inline">\(t_n = n \Delta t\)</span>, pour <span class="math inline">\(n = 0, \ldots, N\)</span>.</p>
<p>On cherche une approximation <span class="math inline">\(U_j^n \approx v(t_n, s_j)\)</span> pour <span class="math inline">\(j = 1, \ldots, J\)</span> et <span class="math inline">\(n = 0, \ldots, N\)</span>. Les sch√©mas aux diff√©rences finies nous permettront de discr√©tiser l‚Äô√©quation de Black-Scholes du prix d‚Äôun put am√©ricain sur cette grille.</p>
<section id="explicit-euler-scheme-or-euler-forward-scheme" class="level2">
<h2 class="anchored" data-anchor-id="explicit-euler-scheme-or-euler-forward-scheme">Explicit Euler Scheme or Euler Forward Scheme</h2>
<p>Le sch√©ma d‚ÄôEuler explicite est un sch√©ma bas√© sur une discr√©tisation explicite en temps. La discr√©tisation de l‚ÄôEDP est bas√©e sur des approximations centr√©es. D√®s lors, on approxime les d√©riv√©es partielles de la mani√®re suivante :</p>
<p><span class="math display">\[
\begin{cases}
min(\frac{U_j^{n+1} - U_j^n}{\Delta t} - \frac{1}{2} \sigma^2 s_j^2 \frac{U_{j+1}^n - 2 U_j^n + U_{j-1}^n}{h^2} - r s_j \frac{U_{j+1}^n - U_{j-1}^n}{2 h} + r U_j^n, U^{n+1}_j - \phi(s_j))= 0, \quad j = 1, \ldots, J,\quad n = 0, \ldots, N-1. \\
U_0^n = v_l(t_n), \quad n = 0, \ldots, N-1. \\
U_{J+1}^n = v_r(t_n), \quad n = 0, \ldots, N-1.
\end{cases}
\]</span></p>
<p>On peut la r√©√©crire sous la forme matricielle afin d‚Äôextraire une solution num√©rique dite explicite : Sous forma matricielle, le sch√©ma s‚Äô√©crit :</p>
<p><span class="math display">\[
\begin{cases}
min(\frac{U^{n+1} - U^n}{\Delta t} +  A U^n + q(t_n), U^{n+1} - g) = 0, \quad n = 0, \ldots, N-1, \\
U^0 = (\phi(s_i))_{1 \leq i \leq J},
\end{cases}
\]</span></p>
<p>o√π - g est un vecteur de <span class="math inline">\(\mathbb{R}^J\)</span> d√©fini par <span class="math inline">\(g_j = \phi(s_j)\)</span> pour <span class="math inline">\(j = 1, \ldots, J\)</span>,</p>
<ul>
<li><p><span class="math inline">\(A\)</span> est une matrice carr√©e tridiagonale de taille <span class="math inline">\(J \times J\)</span>. En posant <span class="math inline">\(\alpha_j = \frac{\sigma^2}{2} \frac{s_j^2}{h^2}\)</span> et <span class="math inline">\(\beta_j = r \frac{s_j}{2 h}\)</span>, les coefficients de la matrice <span class="math inline">\(A\)</span> sont donn√©s par :</p>
<p><span class="math display">\[
\begin{cases}
A_{j,j-1} = -\alpha_j + \beta_j, \quad j= 2, \ldots, J, \\
A_{j,j} = 2\alpha_j + r, \quad j = 1, \ldots, J, \\
A_{j,j+1} = -\alpha_j - \beta_j, \quad j = 1, \ldots, J, \\
\end{cases}
\]</span></p></li>
<li><p><span class="math inline">\(q(t_n)\)</span> un vecteur de <span class="math inline">\(\mathbb{R}^J\)</span> qui d√©pendent des param√®tres du mod√®le et de la discr√©tisation spatiale donn√© par :</p>
<p><span class="math display">\[
q_j(t_n) =
\begin{cases}
(-\alpha_1 + \beta_1) U_0^n, \quad j = 1, \\
0, \quad j = 2, \ldots, J-1, \\
(-\alpha_J + \beta_J) U_{J+1}^n, \quad j = J.
\end{cases}
\]</span></p></li>
</ul>
<p>De fait, on obtient la relation de r√©currence explicite permettant de calculer <span class="math inline">\(U^{n+1}\)</span> en fonction de <span class="math inline">\(U^n\)</span> :</p>
<p><span class="math display">\[
U^{n+1} = max(U^n - \Delta t ( A U^n + q(t_n)), g)), \quad n = 0, \ldots, N-1,
\]</span></p>
</section>
<section id="implicit-euler-scheme" class="level2">
<h2 class="anchored" data-anchor-id="implicit-euler-scheme">Implicit Euler Scheme</h2>
<p>Pour des raisons de stabilit√©, on peut √©galement utiliser un sch√©ma d‚ÄôEuler implicite, qui est bas√© sur une discr√©tisation implicite en temps.</p>
<section id="splitting-scheme" class="level3">
<h3 class="anchored" data-anchor-id="splitting-scheme">Splitting scheme</h3>
<p>Une premi√®re approche est de consid√©rer le ‚Äúsplitting scheme‚Äù, qui consiste √† s√©parer la partie lin√©aire de l‚ÄôEDP de la partie non lin√©aire : (i) On calcule <span class="math inline">\(U^{n+1,(1)}\)</span> tel que <span class="math inline">\(U^{n+1,(1)} - U^n + \Delta t (A U^{n+1,(1)} + q(t_{n+1})) = 0\)</span>, (ii) On calcule <span class="math inline">\(U^{n+1}\)</span> tel que <span class="math inline">\(U^{n+1} = max(U^{n+1,(1)}, g)\)</span>.</p>
</section>
<section id="m√©thodes-num√©riques-de-r√©solution" class="level3">
<h3 class="anchored" data-anchor-id="m√©thodes-num√©riques-de-r√©solution">M√©thodes num√©riques de r√©solution</h3>
<p>Une seconde approche est de consid√©rer un sch√©ma d‚ÄôEuler implicite ‚Äúfully implicit‚Äù, qui consiste √† discr√©tiser l‚ÄôEDP de mani√®re implicite en temps, ce qui conduit √† un syst√®me non lin√©aire √† r√©soudre √† chaque pas de temps : <span class="math display">\[\begin{cases}
min(\frac{U^{n+1} - U^n}{\Delta t} +  A U^{n+1} + q(t_{n+1}), U^{n+1} - g) = 0, \quad n = 0, \ldots, N-1, \\
U^0 = (\phi(s_i))_{1 \leq i \leq J}.
\end{cases}\]</span></p>
<p>En posant <span class="math inline">\(B = I + \Delta t A\)</span> et <span class="math inline">\(b = U^n - \Delta t q(t_{n+1})\)</span>, le probl√®me se transforme en la r√©solution d‚Äôun probl√®me d‚Äôobstacle √† chaque pas de temps ou il s‚Äôagit de trouver <span class="math inline">\(x \in \mathbb{R}^J\)</span> tel que <span class="math inline">\(min(B x - b, x - g) = 0\)</span>. De fait, on a recours √† des m√©thodes num√©riques de r√©solution de ce type de probl√®me, telles que la m√©thode PSOR (projected successive over-relaxation) ou une m√©thode de type Newton.</p>
<section id="psor-algorithm" class="level4">
<h4 class="anchored" data-anchor-id="psor-algorithm">PSOR Algorithm</h4>
<p>La m√©thode PSOR est une m√©thode it√©rative de r√©solution de probl√®mes d‚Äôobstacle. Elle consiste √† it√©rer sur les composantes du vecteur <span class="math inline">\(x\)</span> en appliquant une relaxation projet√©e.</p>
<p>Tout d‚Äôabord, on d√©compose la matrice <span class="math inline">\(B\)</span> en une partie triangulaire inf√©rieure <span class="math inline">\(L\)</span>, et une partie triangulaire strictement sup√©rieure <span class="math inline">\(U\)</span>, de sorte que <span class="math inline">\(B = L + U\)</span>. Ensuite, pour un temps fix√© <span class="math inline">\(n\)</span>, on cherche √† trouver une solution <span class="math inline">\(x\)</span> du probl√®me d‚Äôobstacle en it√©rant sur les composantes du vecteur <span class="math inline">\(x\)</span> au temps fix√© en appliquant la formule suivante : <span class="math display">\[
x_j^{(k+1)} = max\left(g_j, \frac{\omega}{B_{j,j}} \left(b_j - \sum_{i=1}^{j-1} B_{j,i} x_i^{(k+1)} - \sum_{i=j+1}^{J} B_{j,i} x_i^{(k)} \right) + (1 - \omega) x_j^k \right) , \quad j = 1, \ldots, J,
\]</span></p>
<p>o√π <span class="math inline">\(k\)</span> est l‚Äôindice de l‚Äôit√©ration. La m√©thode converge vers la solution du probl√®me d‚Äôobstacle, et le taux de convergence d√©pend du choix du param√®tre de relaxation, i.e.&nbsp;du choix de la valeur de <span class="math inline">\(\omega \in (0,2)\)</span> dans la formule de relaxation. Lorsque <span class="math inline">\(\omega = 1\)</span>, la m√©thode PSOR correspond √† la m√©thode classique de Gauss-Seidel projet√©e. Lorsque <span class="math inline">\(\omega \neq 1\)</span>, la m√©thode PSOR peut acc√©l√©rer la convergence, mais le choix optimal de <span class="math inline">\(\omega\)</span> d√©pend du probl√®me sp√©cifique et peut n√©cessiter une exp√©rimentation.</p>
</section>
<section id="semi-smooth-newtons-method" class="level4">
<h4 class="anchored" data-anchor-id="semi-smooth-newtons-method">Semi-smooth Newton‚Äôs method</h4>
<p>La m√©thode de type Newton est une m√©thode it√©rative de r√©solution de probl√®mes non lin√©aires. Elle consiste √† lin√©ariser le probl√®me d‚Äôobstacle autour d‚Äôune solution approximative <span class="math inline">\(x^{(k)}\)</span> √† chaque it√©ration, et √† r√©soudre le probl√®me lin√©aris√© pour obtenir une nouvelle approximation <span class="math inline">\(x^{(k+1)}\)</span>.</p>
<p>On cherche √† r√©soudre le probl√®me d‚Äôobstacle <span class="math inline">\(F(x) = min(B x - b, x - g) = 0\)</span> en it√©rant sur les approximations successives de la solution. On lin√©arise le probl√®me d‚Äôobstacle autour de l‚Äôapproximation <span class="math inline">\(x^{(k)}\)</span> en utilisant la formule de Taylor : <span class="math display">\[
F(x) \approx F(x^{(k)}) + F'(x^{(k)})(x - x^{(k)}),
\]</span></p>
<p>On cherche √† r√©soudre <span class="math inline">\(F(x) = 0\)</span>. D√®s lors, √† chaque it√©ration, on r√©sout le probl√®me lin√©aris√© <span class="math inline">\(F'(x^{(k)})(x - x^{(k)}) = -F(x^{(k)})\)</span> pour obtenir une nouvelle approximation <span class="math inline">\(x^{(k+1)}\)</span>. La m√©thode de type Newton converge quadratiquement vers la solution du probl√®me d‚Äôobstacle, ce qui en fait une m√©thode tr√®s efficace pour r√©soudre ce type de probl√®me.</p>
<p><span class="math inline">\(F'(x)\)</span> est la matrice jacobienne de <span class="math inline">\(F\)</span> √† l‚Äôapproximation <span class="math inline">\(x\)</span>. La matrice jacobienne de <span class="math inline">\(F\)</span> est donn√©e par : <span class="math display">\[
F'(x)_{i,j} := \begin{cases}
B_{i,j}, \quad \text{si } B x - b &lt; x - g, \\
\delta_{i,j}, \quad \text{sinon}.
\end{cases}
\]</span></p>
</section>
</section>
</section>
<section id="higher-order-schemes" class="level2">
<h2 class="anchored" data-anchor-id="higher-order-schemes">Higher order schemes</h2>
<p>Enfin, nous envisagerons de comparer les sch√©mas d‚ÄôEuler implicite, les sch√©mas de type Crank-Nicolson, et un sch√©ma d‚Äôordre 2 tel que le BDF2.</p>
</section>
</section>
<section id="impl√©mentations" class="level1">
<h1>Impl√©mentations</h1>
<p>Les diff√©rents sch√©mas num√©riques √©tudi√©s pour l‚Äô√©quation de Black‚ÄìScholes avec option am√©ricaine partagent une structure commune. Nous introduisons donc une classe de base abstraite SchemeBase qui regroupe les param√®tres financiers et num√©riques, la construction de la grille discr√®te, les conditions initiales et aux limites, ainsi que la discr√©tisation spatiale de l‚Äôop√©rateur de Black-Scholes √† travers la matrice A et le vecteur q(t).</p>
<p>Les sch√©mas sp√©cifiques h√©ritent de cette classe de base et impl√©mentent la m√©thode solve(). En particulier, nous d√©finissons les classes suivantes : - <code>SchemeEE</code> pour le sch√©ma d‚ÄôEuler explicite, - <code>SplittingScheme</code> pour le sch√©ma splitting d‚ÄôEuler implicite, - <code>SchemeCN</code> pour le sch√©ma de Crank-Nicolson, - <code>PSOR</code> pour la m√©thode PSOR, - <code>NewtonSemiSmooth</code> pour la m√©thode de r√©solution newton semi smooth, et - <code>BdfScheme</code> pour le schema de r√©solution BDF2.</p>
<div id="fde8478d" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Package imports</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.linalg <span class="im">as</span> lng</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.sparse <span class="im">import</span> diags,eye</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> abc <span class="im">import</span> ABC, abstractmethod</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> scipy.stats <span class="im">as</span> stats</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.sparse <span class="im">import</span> csr_matrix <span class="im">as</span> sparse</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy.sparse.linalg <span class="im">import</span> spsolve</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy.linalg <span class="im">as</span> lng</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm <span class="im">import</span> tqdm</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">"ignore"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="0774d7d9" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SchemeBase(ABC):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Classe de base pour les sch√©mas num√©riques de l'√©quation de Black-Scholes.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, r, sigma, K, T, N, J, Smin, Smax, payoff<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Financial parameters</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.r <span class="op">=</span> r</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sigma <span class="op">=</span> sigma</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.K <span class="op">=</span> K</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.T <span class="op">=</span> T</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Numerical parameters</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.N <span class="op">=</span> N</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.J <span class="op">=</span> J</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.Smin <span class="op">=</span> Smin</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.Smax <span class="op">=</span> Smax</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.payoff <span class="op">=</span> payoff</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Grids</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dt <span class="op">=</span> T <span class="op">/</span> N</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.h <span class="op">=</span> (Smax <span class="op">-</span> Smin) <span class="op">/</span> (J <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.s <span class="op">=</span> Smin <span class="op">+</span> <span class="va">self</span>.h <span class="op">*</span> np.arange(<span class="dv">1</span>, J <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Operator</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.A, <span class="va">self</span>.alpha, <span class="va">self</span>.beta <span class="op">=</span> <span class="va">self</span>._build_matrix_A()</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> phi(<span class="va">self</span>,s):</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="co">        Condition initiale (payoff) pour un put am√©ricain.</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="co">        ùúô(s) = max(K - s, 0) si payoff=1</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="co">             = K si K * 0.5 &lt;= s &lt;= K sinon 0 si payoff=2</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.payoff <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> np.maximum(<span class="va">self</span>.K <span class="op">-</span> s, <span class="dv">0</span>)</span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.payoff  <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> np.where((<span class="va">self</span>.K <span class="op">*</span> <span class="fl">0.5</span> <span class="op">&lt;=</span> s) <span class="op">&amp;</span> (s <span class="op">&lt;=</span> <span class="va">self</span>.K), <span class="va">self</span>.K, <span class="dv">0</span>)</span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> uleft(<span class="va">self</span>, t):</span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="co">        Condition aux limites √† gauche pour un put am√©ricain.</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a><span class="co">        u( t, Smin ) = K * exp(-r * t) - S</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.payoff  <span class="op">==</span> <span class="dv">1</span> :</span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.K <span class="op">-</span> <span class="va">self</span>.Smin <span class="cf">if</span> <span class="va">self</span>.Smin <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.payoff  <span class="op">==</span> <span class="dv">2</span> :</span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="fl">0.0</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> uright(<span class="va">self</span>, t):</span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a><span class="co">        Condition aux limites √† droite pour un put am√©ricain.</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a><span class="co">        u( t, Smax ) = 0</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">0.0</span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-57"><a href="#cb2-57" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _build_matrix_A(<span class="va">self</span>):</span>
<span id="cb2-58"><a href="#cb2-58" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb2-59"><a href="#cb2-59" aria-hidden="true" tabindex="-1"></a><span class="co">        Matrice d'amplification A.</span></span>
<span id="cb2-60"><a href="#cb2-60" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb2-61"><a href="#cb2-61" aria-hidden="true" tabindex="-1"></a>        alpha <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="va">self</span>.sigma<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> (<span class="va">self</span>.s<span class="op">**</span><span class="dv">2</span> <span class="op">/</span> <span class="va">self</span>.h<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb2-62"><a href="#cb2-62" aria-hidden="true" tabindex="-1"></a>        beta  <span class="op">=</span> <span class="va">self</span>.r <span class="op">*</span> <span class="va">self</span>.s <span class="op">/</span> (<span class="dv">2</span> <span class="op">*</span> <span class="va">self</span>.h)</span>
<span id="cb2-63"><a href="#cb2-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-64"><a href="#cb2-64" aria-hidden="true" tabindex="-1"></a>        lower <span class="op">=</span> <span class="op">-</span>alpha[<span class="dv">1</span>:] <span class="op">+</span> beta[<span class="dv">1</span>:]        <span class="co"># sous-diagonale</span></span>
<span id="cb2-65"><a href="#cb2-65" aria-hidden="true" tabindex="-1"></a>        main  <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> alpha <span class="op">+</span> <span class="va">self</span>.r            <span class="co"># diagonale principale</span></span>
<span id="cb2-66"><a href="#cb2-66" aria-hidden="true" tabindex="-1"></a>        upper <span class="op">=</span> <span class="op">-</span>alpha[:<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> beta[:<span class="op">-</span><span class="dv">1</span>]       <span class="co"># sur-diagonale</span></span>
<span id="cb2-67"><a href="#cb2-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-68"><a href="#cb2-68" aria-hidden="true" tabindex="-1"></a>        A <span class="op">=</span> diags(</span>
<span id="cb2-69"><a href="#cb2-69" aria-hidden="true" tabindex="-1"></a>            diagonals<span class="op">=</span>[lower, main, upper],</span>
<span id="cb2-70"><a href="#cb2-70" aria-hidden="true" tabindex="-1"></a>            offsets<span class="op">=</span>[<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>],</span>
<span id="cb2-71"><a href="#cb2-71" aria-hidden="true" tabindex="-1"></a>            shape<span class="op">=</span>(<span class="va">self</span>.J, <span class="va">self</span>.J),</span>
<span id="cb2-72"><a href="#cb2-72" aria-hidden="true" tabindex="-1"></a>            <span class="bu">format</span><span class="op">=</span><span class="st">"csr"</span></span>
<span id="cb2-73"><a href="#cb2-73" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb2-74"><a href="#cb2-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-75"><a href="#cb2-75" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> A, alpha, beta</span>
<span id="cb2-76"><a href="#cb2-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-77"><a href="#cb2-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-78"><a href="#cb2-78" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> q(<span class="va">self</span>, t):</span>
<span id="cb2-79"><a href="#cb2-79" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb2-80"><a href="#cb2-80" aria-hidden="true" tabindex="-1"></a><span class="co">        Vecteur des conditions aux limites.</span></span>
<span id="cb2-81"><a href="#cb2-81" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb2-82"><a href="#cb2-82" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> np.zeros(<span class="va">self</span>.J)</span>
<span id="cb2-83"><a href="#cb2-83" aria-hidden="true" tabindex="-1"></a>        y[<span class="dv">0</span>]  <span class="op">=</span> (<span class="op">-</span><span class="va">self</span>.alpha[<span class="dv">0</span>] <span class="op">+</span> <span class="va">self</span>.beta[<span class="dv">0</span>]) <span class="op">*</span> <span class="va">self</span>.uleft(t)</span>
<span id="cb2-84"><a href="#cb2-84" aria-hidden="true" tabindex="-1"></a>        y[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> (<span class="op">-</span><span class="va">self</span>.alpha[<span class="op">-</span><span class="dv">1</span>] <span class="op">-</span> <span class="va">self</span>.beta[<span class="op">-</span><span class="dv">1</span>]) <span class="op">*</span> <span class="va">self</span>.uright(t)</span>
<span id="cb2-85"><a href="#cb2-85" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> y</span>
<span id="cb2-86"><a href="#cb2-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-87"><a href="#cb2-87" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> interpolate(<span class="va">self</span>, Sval, U):</span>
<span id="cb2-88"><a href="#cb2-88" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb2-89"><a href="#cb2-89" aria-hidden="true" tabindex="-1"></a><span class="co">        Interpolation lin√©aire pour obtenir la valeur approxim√©e d'un put</span></span>
<span id="cb2-90"><a href="#cb2-90" aria-hidden="true" tabindex="-1"></a><span class="co">        en un point spot Sval donn√©.</span></span>
<span id="cb2-91"><a href="#cb2-91" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb2-92"><a href="#cb2-92" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> Sval <span class="op">&lt;=</span> <span class="va">self</span>.Smin:</span>
<span id="cb2-93"><a href="#cb2-93" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.uleft(<span class="va">self</span>.T)</span>
<span id="cb2-94"><a href="#cb2-94" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> Sval <span class="op">&gt;=</span> <span class="va">self</span>.Smax:</span>
<span id="cb2-95"><a href="#cb2-95" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.uright(<span class="va">self</span>.T)</span>
<span id="cb2-96"><a href="#cb2-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb2-97"><a href="#cb2-97" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> np.interp(Sval, <span class="va">self</span>.s, U)</span>
<span id="cb2-98"><a href="#cb2-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-99"><a href="#cb2-99" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Abstract method</span></span>
<span id="cb2-100"><a href="#cb2-100" aria-hidden="true" tabindex="-1"></a>    <span class="at">@abstractmethod</span></span>
<span id="cb2-101"><a href="#cb2-101" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> solve(<span class="va">self</span>):</span>
<span id="cb2-102"><a href="#cb2-102" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb2-103"><a href="#cb2-103" aria-hidden="true" tabindex="-1"></a><span class="co">        M√©thode abstraite de r√©solution du sch√©ma num√©rique.</span></span>
<span id="cb2-104"><a href="#cb2-104" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb2-105"><a href="#cb2-105" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">NotImplementedError</span>(<span class="st">"M√©thode solve() √† impl√©menter dans la classe fille"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="39b0ad94" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SchemeEE(SchemeBase):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Sch√©ma d'Euler explicite.</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, r, sigma, K, T, N, J, Smin, Smax, payoff<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(r, sigma, K, T, N, J, Smin, Smax, payoff)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scheme_name <span class="op">=</span> <span class="st">"EE"</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> solve(<span class="va">self</span>):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="co">        R√©solution du sch√©ma d'Euler explicite.</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co">        """</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> <span class="va">self</span>.phi(<span class="va">self</span>.s)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        g <span class="op">=</span> <span class="va">self</span>.phi(<span class="va">self</span>.s)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.N):</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> n <span class="op">*</span> <span class="va">self</span>.dt</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            U <span class="op">=</span> np.maximum(U <span class="op">-</span> <span class="va">self</span>.dt <span class="op">*</span> (<span class="va">self</span>.A <span class="op">@</span> U <span class="op">+</span> <span class="va">self</span>.q(t)), g)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U,t</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="380f7eb2" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SplittingScheme(SchemeBase):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Sch√©ma d'Euler implicite "Splitting scheme".</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, r, sigma, K, T, N, J, Smin, Smax, payoff<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(r, sigma, K, T, N, J, Smin, Smax, payoff)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scheme_name <span class="op">=</span> <span class="st">"EI-AMER-SPLIT"</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> solve(<span class="va">self</span>):</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> <span class="va">self</span>.phi(<span class="va">self</span>.s)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        g <span class="op">=</span> <span class="va">self</span>.phi(<span class="va">self</span>.s)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        I <span class="op">=</span> eye(<span class="va">self</span>.J, <span class="bu">format</span><span class="op">=</span><span class="st">"csr"</span>)</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.N):</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> n <span class="op">*</span> <span class="va">self</span>.dt</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            U <span class="op">=</span> spsolve(I <span class="op">+</span> <span class="va">self</span>.dt <span class="op">*</span> <span class="va">self</span>.A, U <span class="op">-</span> <span class="va">self</span>.dt <span class="op">*</span> <span class="va">self</span>.q(t))</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            U <span class="op">=</span> np.maximum(U, g)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U,t</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="3311bfee" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> SchemeCN(SchemeBase):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Sch√©ma de Crank-Nicolson.</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, r, sigma, K, T, N, J, Smin, Smax, payoff<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(r, sigma, K, T, N, J, Smin, Smax, payoff)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scheme_name <span class="op">=</span> <span class="st">"CN-AMER-SPLIT"</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> solve(<span class="va">self</span>):</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> <span class="va">self</span>.phi(<span class="va">self</span>.s)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        g <span class="op">=</span> <span class="va">self</span>.phi(<span class="va">self</span>.s)</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        I <span class="op">=</span> eye(<span class="va">self</span>.J, <span class="bu">format</span><span class="op">=</span><span class="st">"csr"</span>)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        factor_minus <span class="op">=</span> I <span class="op">-</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="va">self</span>.dt <span class="op">*</span> <span class="va">self</span>.A</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        factor_plus <span class="op">=</span> I <span class="op">+</span> <span class="fl">0.5</span> <span class="op">*</span> <span class="va">self</span>.dt <span class="op">*</span> <span class="va">self</span>.A</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.N):</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> n <span class="op">*</span> <span class="va">self</span>.dt</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>            U <span class="op">=</span> spsolve(factor_plus, factor_minus<span class="op">@</span>U <span class="op">-</span> <span class="va">self</span>.dt <span class="op">*</span> <span class="va">self</span>.q(t))</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>            U <span class="op">=</span> np.maximum(U, g)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U,t</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="3cc80206" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> PSOR(SchemeBase):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Sch√©ma PSOR</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, r, sigma, K, T, N, J, Smin, Smax, payoff<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(r, sigma, K, T, N, J, Smin, Smax, payoff)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scheme_name <span class="op">=</span> <span class="st">"EI-AMER-PSOR"</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> solve(<span class="va">self</span>, omega<span class="op">=</span><span class="dv">1</span>, tol<span class="op">=</span><span class="fl">1e-6</span>, max_iter_<span class="op">=</span><span class="dv">100</span>):</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        g <span class="op">=</span> <span class="va">self</span>.phi(<span class="va">self</span>.s).copy()</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        I <span class="op">=</span> eye(<span class="va">self</span>.J, <span class="bu">format</span><span class="op">=</span><span class="st">"csr"</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        B <span class="op">=</span> I <span class="op">+</span> <span class="va">self</span>.dt <span class="op">*</span> <span class="va">self</span>.A</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> g.copy()</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Boucle en temps</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.N):</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> n <span class="op">*</span> <span class="va">self</span>.dt</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Second membre f = U^{n+1} + dt * q(t_n)</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>            b <span class="op">=</span> U <span class="op">+</span> <span class="va">self</span>.dt <span class="op">*</span> <span class="va">self</span>.q(t)</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Initialisation PSOR</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>            U_new <span class="op">=</span> U.copy()</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Boucle PSOR</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(max_iter_):</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>                U_old <span class="op">=</span> U_new.copy()</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Boucle spatiale</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.J):</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>                    s1 <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>                        s1 <span class="op">+=</span> B[i, j] <span class="op">*</span> U_new[j]</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>                    s2 <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, <span class="va">self</span>.J):</span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>                        s2 <span class="op">+=</span> B[i, j] <span class="op">*</span> U_old[j]</span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>                    ci <span class="op">=</span> (b[i] <span class="op">-</span> s1 <span class="op">-</span> s2) <span class="op">/</span> B[i, i]</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>                    U_new[i] <span class="op">=</span> <span class="bu">max</span>(</span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>                        (<span class="dv">1</span> <span class="op">-</span> omega )<span class="op">*</span> U_old[i] <span class="op">+</span> omega <span class="op">*</span> ci     ,</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>                        g[i]</span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>                    )</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>                error1 <span class="op">=</span> lng.norm(U_new <span class="op">-</span> U_old)</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>                <span class="co"># error2 = lng.norm(np.minimum(B @ U_new - b, U_new - g))</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Crit√®re de convergence PSOR</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> error1 <span class="op">&lt;</span> tol:</span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Passage au temps suivant</span></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>            U <span class="op">=</span> U_new.copy()</span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U, <span class="va">self</span>.T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="8922a532" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> NewtonSemiSmooth(SchemeBase):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Euler implicite + Newton semi-smooth</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">    pour option am√©ricaine (probl√®me d'obstacle)</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, r, sigma, K, T, N, J, Smin, Smax, payoff<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(r, sigma, K, T, N, J, Smin, Smax, payoff)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scheme_name <span class="op">=</span> <span class="st">"EI-AMER-NEWTON-SS"</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> solve(<span class="va">self</span>, tol<span class="op">=</span><span class="fl">1e-8</span>, max_iter_<span class="op">=</span><span class="dv">20</span>):</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Obstacle (payoff)</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        g <span class="op">=</span> <span class="va">self</span>.phi(<span class="va">self</span>.s).copy()</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Matrice implicite</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        I <span class="op">=</span> eye(<span class="va">self</span>.J, <span class="bu">format</span><span class="op">=</span><span class="st">"csr"</span>)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        B <span class="op">=</span> I <span class="op">+</span> <span class="va">self</span>.dt <span class="op">*</span> <span class="va">self</span>.A</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Condition terminale</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        U <span class="op">=</span> g.copy()</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.N):</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> n <span class="op">*</span> <span class="va">self</span>.dt</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>            b <span class="op">=</span> U <span class="op">+</span> <span class="va">self</span>.dt <span class="op">*</span> <span class="va">self</span>.q(t)</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> U.copy()</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Boucle Newton semi-smooth</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(max_iter_):</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>                <span class="co"># F(x)</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>                Bx_b <span class="op">=</span> B <span class="op">@</span> x <span class="op">-</span> b</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>                x_g  <span class="op">=</span> x <span class="op">-</span> g</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>                F <span class="op">=</span> np.minimum(Bx_b, x_g)</span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Test d'arr√™t</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> lng.norm(F, np.inf) <span class="op">&lt;</span> tol:</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Construction de F'(x) (jacobienne g√©n√©ralis√©e)</span></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>                rows, cols, data <span class="op">=</span> [], [], []</span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.J):</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> Bx_b[i] <span class="op">&lt;=</span> x_g[i]:</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># ligne i de B</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>                        row <span class="op">=</span> B.getrow(i)</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>                        rows.extend([i] <span class="op">*</span> <span class="bu">len</span>(row.indices))</span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>                        cols.extend(row.indices)</span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>                        data.extend(row.data)</span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span>:</span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>                        <span class="co"># ligne i de I</span></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>                        rows.append(i)</span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>                        cols.append(i)</span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>                        data.append(<span class="fl">1.0</span>)</span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a>                DF <span class="op">=</span> sparse((data, (rows, cols)), shape<span class="op">=</span>(<span class="va">self</span>.J, <span class="va">self</span>.J))</span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>                <span class="co"># √âtape de Newton : DF * delta = F</span></span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>                delta <span class="op">=</span> spsolve(DF, F)</span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Mise √† jour</span></span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>                x <span class="op">=</span> x <span class="op">-</span> delta</span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Passage au temps suivant</span></span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>            U <span class="op">=</span> x.copy()</span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U, <span class="va">self</span>.T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="07d47efa" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BdfScheme(SchemeBase):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Sch√©ma BDF2</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, r, sigma, K, T, N, J, Smin, Smax, payoff<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">super</span>().<span class="fu">__init__</span>(r, sigma, K, T, N, J, Smin, Smax, payoff)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.scheme_name <span class="op">=</span> <span class="st">"BDF2-Obstacle-Newton"</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> solve(<span class="va">self</span>):</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Obstacle</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        g <span class="op">=</span> <span class="va">self</span>.phi(<span class="va">self</span>.s).copy()</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        I <span class="op">=</span> eye(<span class="va">self</span>.J, <span class="bu">format</span><span class="op">=</span><span class="st">"csr"</span>)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ---------- Initialisation ----------</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="co"># U^0</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        U_nm1 <span class="op">=</span> g.copy()</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># U^1 via Euler implicite (avec obstacle)</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        B_euler <span class="op">=</span> I <span class="op">+</span> <span class="va">self</span>.dt <span class="op">*</span> <span class="va">self</span>.A</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        b_euler <span class="op">=</span> U_nm1 <span class="op">+</span> <span class="va">self</span>.dt <span class="op">*</span> <span class="va">self</span>.q(<span class="va">self</span>.dt)</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        U_n <span class="op">=</span> spsolve(B_euler, b_euler)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        U_n <span class="op">=</span> np.maximum(U_n, g)   <span class="co"># projection autoris√©e uniquement ici (Euler)</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ---------- Boucle BDF2 ----------</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="va">self</span>.N):</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>            t <span class="op">=</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="op">*</span> <span class="va">self</span>.dt</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>            factor1 <span class="op">=</span> (<span class="fl">3.0</span> <span class="op">/</span> (<span class="fl">2.0</span> <span class="op">*</span> <span class="va">self</span>.dt)) <span class="op">*</span> I <span class="op">+</span> <span class="va">self</span>.A</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>            factor2 <span class="op">=</span> (<span class="fl">4.0</span> <span class="op">*</span> U_n <span class="op">-</span> U_nm1) <span class="op">/</span> (<span class="fl">2.0</span> <span class="op">*</span> <span class="va">self</span>.dt) <span class="op">-</span> <span class="va">self</span>.q(t)</span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>            U <span class="op">=</span> spsolve(factor1, factor2)</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>            U <span class="op">=</span> np.maximum(U, g)</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>            U_nm1 <span class="op">=</span> U_n.copy()</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>            U_n <span class="op">=</span> U.copy()</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> U, <span class="va">self</span>.T</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="r√©sultats-des-sch√©mas-num√©riques" class="level1">
<h1>R√©sultats des sch√©mas num√©riques</h1>
<section id="euler-explicit-scheme" class="level2">
<h2 class="anchored" data-anchor-id="euler-explicit-scheme">Euler Explicit Scheme</h2>
<p>Nous √©tudions ici le comportement du sch√©ma d‚ÄôEuler explicite appliqu√© √† l‚Äô√©quation de Black‚ÄìScholes pour une option am√©ricaine de type put. Les simulations sont r√©alis√©es en faisant varier les param√®tres de discr√©tisation spatiale J et temporelle N, tout en imposant la contrainte d‚Äôobstacle √† chaque pas de temps.</p>
<p>Les figures pr√©sent√©es correspondent aux cas suivants (pour les deux payoffs consid√©r√©s) :</p>
<ul>
<li>N = 20, J = 50</li>
<li>N = 20, J = 20</li>
<li>N = 50, J = 20</li>
</ul>
<p>Pour chaque configuration, le prix num√©rique de l‚Äôoption est compar√© au payoff, et la valeur associ√©e √† la condition de CFL est calcul√©e.</p>
<div id="43215ab6" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>r_ <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>sigma_ <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>K_ <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>T_ <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>Smin_ <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>Smax_ <span class="op">=</span> <span class="dv">250</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Param√®tres financiers:"</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"r=</span><span class="sc">%.2f</span><span class="st">"</span> <span class="op">%</span>r_, <span class="st">"sigma=</span><span class="sc">%.2f</span><span class="st">"</span> <span class="op">%</span>sigma_, <span class="st">"K=%.0f"</span> <span class="op">%</span>K_, <span class="st">"T=%.0f"</span> <span class="op">%</span>T_)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Definition des param√®tres dans un dictionnaire</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>params <span class="op">=</span> <span class="bu">dict</span>(</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    r<span class="op">=</span>r_,</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    sigma<span class="op">=</span>sigma_,</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    K<span class="op">=</span>K_,</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    T<span class="op">=</span>T_,</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    N<span class="op">=</span><span class="va">None</span>, <span class="co"># Valeur √† d√©finir plus tard</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    J<span class="op">=</span><span class="va">None</span>, <span class="co"># Valeur √† d√©finir plus tard</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    Smin<span class="op">=</span>Smin_,</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    Smax<span class="op">=</span>Smax_</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Param√®tres financiers:
r=0.10 sigma=0.30 K=100 T=1</code></pre>
</div>
</div>
<div id="a196213e" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>J_values <span class="op">=</span> [<span class="dv">50</span>, <span class="dv">20</span>, <span class="dv">20</span>]</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>N_values <span class="op">=</span> [<span class="dv">20</span>, <span class="dv">20</span>, <span class="dv">50</span>]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>cfl_records1 <span class="op">=</span> []</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">24</span>, <span class="dv">8</span>), sharey<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j, (N_, J_) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(N_values, J_values)):</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    params[<span class="st">'N'</span>] <span class="op">=</span> N_</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    params[<span class="st">'J'</span>] <span class="op">=</span> J_</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    ee <span class="op">=</span> SchemeEE(<span class="op">**</span>params, payoff<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    U, t <span class="op">=</span> ee.solve()</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> ee.s</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> ee.dt</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">#CFL condition</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    CFL <span class="op">=</span> dt <span class="op">/</span> (ee.h <span class="op">**</span> <span class="dv">2</span>) <span class="op">*</span> (ee.sigma <span class="op">**</span> <span class="dv">2</span>) <span class="op">*</span> (ee.Smax <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Enregistrement dans la table</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    cfl_records1.append({</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        <span class="st">"N"</span>: N_,</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        <span class="st">"J"</span>: J_,</span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>        <span class="st">"CFL"</span>: CFL</span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> axes[j]</span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    ax.plot(s, U, label<span class="op">=</span><span class="st">"Prix option"</span>)</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    ax.plot(s, ee.phi(s), <span class="st">'k--'</span>, label<span class="op">=</span><span class="st">"Payoff"</span>)</span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="ss">f"N = </span><span class="sc">{</span>N_<span class="sc">}</span><span class="ss">, J = </span><span class="sc">{</span>J_<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">"s"</span>)</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> j <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a>        ax.set_ylabel(<span class="st">"u(t,s)"</span>)</span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>    ax.legend()</span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a>plt.suptitle(</span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f"Evolution du prix du put am√©ricain -- Scheme </span><span class="sc">{</span>ee<span class="sc">.</span>scheme_name<span class="sc">}</span><span class="ss">"</span>,</span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a>    fontsize<span class="op">=</span><span class="dv">16</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>plt.tight_layout(rect<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.95</span>])</span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="edp_american_opt_files/figure-html/cell-11-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="18523a2c" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>J_values <span class="op">=</span> [<span class="dv">50</span>, <span class="dv">20</span>, <span class="dv">20</span>]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>N_values <span class="op">=</span> [<span class="dv">20</span>, <span class="dv">20</span>, <span class="dv">50</span>]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>cfl_records2 <span class="op">=</span> []</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>fig, axes <span class="op">=</span> plt.subplots(<span class="dv">1</span>, <span class="dv">3</span>, figsize<span class="op">=</span>(<span class="dv">24</span>, <span class="dv">8</span>), sharey<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j, (N_, J_) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(N_values, J_values)):</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    params[<span class="st">'N'</span>] <span class="op">=</span> N_</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    params[<span class="st">'J'</span>] <span class="op">=</span> J_</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    ee <span class="op">=</span> SchemeEE(<span class="op">**</span>params, payoff<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    U, t <span class="op">=</span> ee.solve()</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    s <span class="op">=</span> ee.s</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    dt <span class="op">=</span> ee.dt</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">#CFL condition</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    CFL <span class="op">=</span> dt <span class="op">/</span> (ee.h <span class="op">**</span> <span class="dv">2</span>) <span class="op">*</span> (ee.sigma <span class="op">**</span> <span class="dv">2</span>) <span class="op">*</span> (ee.Smax <span class="op">**</span> <span class="dv">2</span>)</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Enregistrement dans la table</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    cfl_records2.append({</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        <span class="st">"N"</span>: N_,</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        <span class="st">"J"</span>: J_,</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>        <span class="st">"CFL"</span>: CFL</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>    ax <span class="op">=</span> axes[j]</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>    ax.plot(s, U, label<span class="op">=</span><span class="st">"Prix option"</span>)</span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>    ax.plot(s, ee.phi(s), <span class="st">'k--'</span>, label<span class="op">=</span><span class="st">"Payoff"</span>)</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>    ax.set_title(<span class="ss">f"N = </span><span class="sc">{</span>N_<span class="sc">}</span><span class="ss">, J = </span><span class="sc">{</span>J_<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>    ax.set_xlabel(<span class="st">"s"</span>)</span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> j <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>        ax.set_ylabel(<span class="st">"u(t,s)"</span>)</span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>    ax.legend()</span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>plt.suptitle(</span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f"Evolution du prix du put am√©ricain -- Scheme </span><span class="sc">{</span>ee<span class="sc">.</span>scheme_name<span class="sc">}</span><span class="ss">, N fix√© √† </span><span class="sc">{</span>N_<span class="sc">}</span><span class="ss">"</span>,</span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>    fontsize<span class="op">=</span><span class="dv">16</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a>plt.tight_layout(rect<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.95</span>])</span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="edp_american_opt_files/figure-html/cell-12-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Les figures ci - dessus repr√©sentent le prix num√©rique de l‚Äôoption au temps final, compar√© au payoff, pour diff√©rentes configurations de maillage.</p>
<p>Les r√©sultats montrent que le comportement du sch√©ma d√©pend fortement du choix de N et J. Lorsque le maillage spatial est fin ( J=50) et que le nombre de pas de temps est relativement faible ( N=20), la solution num√©rique devient instable et pr√©sente de fortes oscillations, avec des valeurs non physiques. Ce ph√©nom√®ne traduit une instabilit√© du sch√©ma explicite. En revanche, pour un maillage spatial plus grossier ( J=20) et un pas de temps suffisamment petit ( N=20 ou N=50), la solution obtenue est plus r√©guli√®re et respecte correctement la contrainte d‚Äôoption am√©ricaine, la solution restant au-dessus du payoff.</p>
<p>Ces observations sugg√®rent que la stabilit√© du sch√©ma d‚ÄôEuler explicite est √©troitement li√©e √† la relation entre le pas de temps et le pas d‚Äôespace, ce qui motive l‚Äôanalyse de la condition de stabilit√© de type CFL.</p>
<div id="3fc192bc" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>cfl_df1 <span class="op">=</span> pd.DataFrame(cfl_records1)  <span class="co"># Cas 1 : N fix√©</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>cfl_df2 <span class="op">=</span> pd.DataFrame(cfl_records2)  <span class="co"># Cas 2 : N = J</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>cfl_df1 <span class="op">=</span> cfl_df1.rename(columns<span class="op">=</span>{<span class="st">"CFL"</span>: <span class="st">"CFL (N=10)"</span>})</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>cfl_df2 <span class="op">=</span> cfl_df2.rename(columns<span class="op">=</span>{<span class="st">"CFL"</span>: <span class="st">"CFL (N=J)"</span>})</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Payoff standard:"</span>)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">20</span>)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cfl_df1)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Payoff tronqu√©:"</span>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">20</span>)</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(cfl_df2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Payoff standard:
====================
    N   J  CFL (N=10)
0  20  50   18.288281
1  20  20    3.100781
2  50  20    1.240312
Payoff tronqu√©:
====================
    N   J  CFL (N=J)
0  20  50  18.288281
1  20  20   3.100781
2  50  20   1.240312</code></pre>
</div>
</div>
<p>L‚Äô√©tude de la condition de CFL met en √©vidence le caract√®re conditionnellement stable du sch√©ma d‚ÄôEuler explicite. Comme observ√© sur les figures, lorsque le maillage spatial est raffin√© sans diminution suffisante du pas de temps, la condition de stabilit√© est viol√©e et la solution num√©rique pr√©sente des oscillations marqu√©es. √Ä l‚Äôinverse, lorsque N et J sont augment√©s conjointement, la condition de CFL est mieux respect√©e et le comportement du sch√©ma s‚Äôam√©liore.</p>
<p>On remarque par ailleurs que les valeurs calcul√©es de la CFL sont identiques pour le payoff standard et pour le payoff tronqu√©. Ce r√©sultat est attendu, puisque la condition de stabilit√© d√©pend uniquement des param√®tres num√©riques et du mod√®le, en particulier du pas de temps Œît, du pas d‚Äôespace h, de la volatilit√© œÉ et de la borne sup√©rieure Smax et non de la r√©gularit√© du payoff.</p>
<div id="87861e0d" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_convergence_table(N_grid, J_grid, params, Sval, scheme_class):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    est_prices <span class="op">=</span> []</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    errex <span class="op">=</span> []</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    errors <span class="op">=</span> []</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    cpu_times <span class="op">=</span> []</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> N, J <span class="kw">in</span> <span class="bu">zip</span>(N_grid, J_grid):</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        params[<span class="st">'N'</span>] <span class="op">=</span> N</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        params[<span class="st">'J'</span>] <span class="op">=</span> J</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>        start <span class="op">=</span> time.time()</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>        scheme <span class="op">=</span> scheme_class(<span class="op">**</span>params)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        U, _ <span class="op">=</span> scheme.solve()</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>        tcpu <span class="op">=</span> time.time() <span class="op">-</span> start</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        price_est <span class="op">=</span> scheme.interpolate(Sval, U)</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>        est_prices.append(price_est)</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>        cpu_times.append(tcpu)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    est_prices <span class="op">=</span> np.array(est_prices)</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>    errors <span class="op">=</span> np.zeros(<span class="bu">len</span>(est_prices))</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>    errors[<span class="dv">1</span>:] <span class="op">=</span> np.<span class="bu">abs</span>(np.diff(est_prices))</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>    cpu_times <span class="op">=</span> np.array(cpu_times)</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ordre de convergence global</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>    alpha <span class="op">=</span> np.zeros(<span class="bu">len</span>(errors))</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>    h_step <span class="op">=</span> (params[<span class="st">"Smax"</span>] <span class="op">-</span> params[<span class="st">"Smin"</span>]) <span class="op">/</span> (J_grid <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>    alpha[<span class="dv">1</span>:] <span class="op">=</span> np.where(</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a>        (errors[:<span class="op">-</span><span class="dv">1</span>] <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">&amp;</span> (errors[<span class="dv">1</span>:] <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">&amp;</span> (h_step[:<span class="op">-</span><span class="dv">1</span>] <span class="op">&gt;</span> h_step[<span class="dv">1</span>:]),</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a>        np.log(errors[:<span class="op">-</span><span class="dv">1</span>] <span class="op">/</span> errors[<span class="dv">1</span>:]) <span class="op">/</span> np.log(h_step[:<span class="op">-</span><span class="dv">1</span>] <span class="op">/</span> h_step[<span class="dv">1</span>:]),</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a>        <span class="dv">0</span></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a>    df <span class="op">=</span> pd.DataFrame({</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a>        <span class="st">"J"</span>: J_grid,</span>
<span id="cb15-37"><a href="#cb15-37" aria-hidden="true" tabindex="-1"></a>        <span class="st">"N"</span>: N_grid,</span>
<span id="cb15-38"><a href="#cb15-38" aria-hidden="true" tabindex="-1"></a>        <span class="st">"U(s)"</span>: est_prices,</span>
<span id="cb15-39"><a href="#cb15-39" aria-hidden="true" tabindex="-1"></a>        <span class="st">"error"</span>: errors,</span>
<span id="cb15-40"><a href="#cb15-40" aria-hidden="true" tabindex="-1"></a>        <span class="st">"alpha"</span>: alpha,</span>
<span id="cb15-41"><a href="#cb15-41" aria-hidden="true" tabindex="-1"></a>        <span class="st">"tcpu"</span>: cpu_times</span>
<span id="cb15-42"><a href="#cb15-42" aria-hidden="true" tabindex="-1"></a>    })</span>
<span id="cb15-43"><a href="#cb15-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-44"><a href="#cb15-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> df.<span class="bu">round</span>(<span class="dv">6</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="1517e2a2" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>Sval <span class="op">=</span> <span class="dv">90</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>J_grid <span class="op">=</span> np.array([<span class="dv">20</span>, <span class="dv">40</span>, <span class="dv">80</span>, <span class="dv">160</span>, <span class="dv">320</span>])</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>N_grid <span class="op">=</span> np.array([<span class="dv">2</span><span class="op">*</span>(j<span class="op">**</span><span class="dv">2</span>)<span class="op">/</span><span class="dv">10</span> <span class="cf">for</span> j <span class="kw">in</span> J_grid]).astype(<span class="bu">int</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Cas N = J</span><span class="ch">\n</span><span class="st">"</span>, <span class="st">"="</span><span class="op">*</span><span class="dv">75</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Convergence Table for Scheme EE:"</span>)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(get_convergence_table(N_grid, J_grid<span class="op">-</span><span class="dv">1</span>, params, Sval, SchemeEE))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Cas N = J
 ===========================================================================
Convergence Table for Scheme EE:
     J      N       U(s)     error     alpha      tcpu
0   19     80  12.947098  0.000000  0.000000  0.000573
1   39    320  13.064717  0.117619  0.000000  0.001415
2   79   1280  13.109572  0.044855  1.390781  0.005432
3  159   5120  13.117805  0.008233  2.445784  0.019646
4  319  20480  13.119987  0.002183  1.915301  0.082647</code></pre>
</div>
</div>
<p>ordre h^2 + dt ==&gt; division de l‚Äôerreur par 4.</p>
<!-- ### Condition de stabilit√© (CFL) et convergence -->
<!-- L‚Äô√©tude de la condition de CFL met en √©vidence le caract√®re conditionnellement stable du sch√©ma d‚ÄôEuler explicite. Comme observ√© sur les figures, lorsque le maillage spatial est raffin√© sans diminution suffisante du pas de temps, la condition de stabilit√© est viol√©e et la solution num√©rique pr√©sente des oscillations marqu√©es. √Ä l‚Äôinverse, lorsque
N et J sont augment√©s conjointement, la condition de CFL est mieux respect√©e et le comportement du sch√©ma s‚Äôam√©liore.

On remarque par ailleurs que les valeurs calcul√©es de la CFL sont identiques pour le payoff standard et pour le payoff tronqu√©. Ce r√©sultat est attendu, puisque la condition de stabilit√© d√©pend uniquement des param√®tres num√©riques et du mod√®le, en particulier du pas de temps
Œît, du pas d‚Äôespace h, de la volatilit√©
œÉ et de la borne sup√©rieure
Smax et non de la r√©gularit√© du payoff. -->
<p>Pour compl√©ter l‚Äôanalyse de la stabilit√©, il est √©galement int√©ressant d‚Äô√©tudier la convergence du sch√©ma. Pour √©tudier l‚Äôordre de convergence du sch√©ma, nous avons utilis√© une grille pour J qui varie en doublant √† chaque fois, et une grille pour N qui varie selon la r√®gle <span class="math inline">\(2 \times \frac{J^2}{10}\)</span>. Etant donn√© le fait que l‚Äôordre th√©orique de convergence du sch√©ma d‚ÄôEuler explicite pour l‚Äô√©quation de Black-Scholes est de 2 en espace et de 1 en temps, on s‚Äôattend √† ce que l‚Äôerreur diminue d‚Äôun facteur de 4 √† chaque √©volution de la grille. La table de convergence pr√©sent√©e ci-dessous montre l‚Äô√©volution de la solution num√©rique U(s) lorsque le nombre de points spatiaux J et le nombre de pas temporels N sont augment√©s.</p>
<p>En respectant la r√®gle de variation des grilles pour J et N, on s‚Äôassure que les deux contributions √† l‚Äôerreur, i.e.&nbsp;l‚Äôerreur spatiale et l‚Äôerreur temporelle, diminuent de mani√®re coh√©rente, ce qui permet d‚Äôobserver une convergence plus r√©guli√®re du sch√©ma et donc un ordre de convergence plus clair.</p>
<p>On observe que l‚Äôerreur diminue progressivement au fur et √† mesure que le maillage spatial et temporel est raffin√©, tandis que le facteur Œ± (estimant l‚Äôordre de convergence en espace) tend vers la valeur th√©orique attendue (2), ce qui confirme que le sch√©ma d‚ÄôEuler explicite converge correctement sous la condition de CFL.</p>
<p>La colonne tcpu montre que ce raffinement s‚Äôaccompagne d‚Äôun co√ªt computationnel croissant, le temps de calcul augmentant rapidement lorsque le maillage spatial et temporel est affin√©.</p>
</section>
<section id="schemas-implicites" class="level2">
<h2 class="anchored" data-anchor-id="schemas-implicites">Schemas implicites</h2>
<p>Apr√®s avoir √©tudi√© le sch√©ma d‚ÄôEuler explicite, nous nous int√©ressons √† des sch√©mas implicites et semi-implicites (Euler implicite, Crank-Nicolson‚Ä¶). Ce passage est principalement motiv√© par le fait que le sch√©ma explicite est conditionnellement stable et impose une limitation relativement stricte sur le pas de temps Œît et le maillage via la condition CFL. Les sch√©mas implicites, eux, offrent une stabilit√© plus grande, permettant d‚Äôutiliser des pas de temps plus importants.</p>
<p>Dans le cas du sch√©ma d‚ÄôEuler implicite (et plus g√©n√©ralement pour tout sch√©ma implicite appliqu√© aux options am√©ricaines), on est conduit √† r√©soudre √† chaque pas de temps un syst√®me non lin√©aire discret, correspondant √† un probl√®me d‚Äôobstacle v‚â•œï. Pour traiter ce syst√®me, nous utilisons diverses m√©thodes num√©riques, telles que la m√©thode PSOR (Projected Successive Over-Relaxation) ou une m√©thode de type Newton semi-smooth.</p>
<p>Ces sch√©mas compl√©mentaires nous permettent donc de comparer pr√©cision, stabilit√© et co√ªt computationnel, tout en g√©rant correctement la contrainte inh√©rente aux options am√©ricaines.</p>
<section id="splitting-euler-implicit-scheme-splitting-crank-nicolson-scheme" class="level3">
<h3 class="anchored" data-anchor-id="splitting-euler-implicit-scheme-splitting-crank-nicolson-scheme">Splitting Euler Implicit scheme &amp; Splitting Crank-Nicolson Scheme</h3>
<p>Pour √©tudier le comportement du sch√©ma splitting d‚ÄôEuler implicite, nous nous sommes directement plac√©s dans le cas o√π N=20 et J=50, qui avait montr√© des oscillations dans le sch√©ma explicite. Les r√©sultats obtenus sont pr√©sent√©s dans le graphique ci-dessous. Comme on peut le constater, le sch√©ma d‚ÄôEuler implicite produit une approximation stable et sans oscillations du prix du put europ√©en, m√™me pour des valeurs √©lev√©es de N et J. Cela confirme la stabilit√© inconditionnelle du sch√©ma implicite, qui ne d√©pend pas de la relation entre le pas de temps et le pas d‚Äôespace.</p>
<div id="ccd4d4f9" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>params[<span class="st">'J'</span>] <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>params[<span class="st">'N'</span>] <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Param√®tres financiers:"</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"r=</span><span class="sc">%.2f</span><span class="st">"</span> <span class="op">%</span>r_, <span class="st">"sigma=</span><span class="sc">%.2f</span><span class="st">"</span> <span class="op">%</span>sigma_, <span class="st">"K=%.0f"</span> <span class="op">%</span>K_, <span class="st">"T=%.0f"</span> <span class="op">%</span>T_)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Param√®tres num√©riques:"</span>)</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"J=%.0f"</span> <span class="op">%</span>params[<span class="st">'J'</span>], <span class="st">"N=%.0f"</span> <span class="op">%</span>params[<span class="st">'N'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Param√®tres financiers:
r=0.10 sigma=0.30 K=100 T=1
Param√®tres num√©riques:
J=20 N=50</code></pre>
</div>
</div>
<div id="f68ee015" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>ei_split <span class="op">=</span> SplittingScheme(<span class="op">**</span>params)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>U,t <span class="op">=</span> ei_split.solve()</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> ei_split.s</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> ei_split.dt</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>plt.plot(s,U,label<span class="op">=</span><span class="st">"t=</span><span class="sc">%.2f</span><span class="st">"</span> <span class="op">%</span>(t<span class="op">+</span>dt))</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>plt.plot(s,ei_split.phi(s), <span class="st">'k--'</span>, label<span class="op">=</span><span class="st">"payoff"</span>)</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"s"</span>)</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"u(t,s)"</span>)</span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Evolution du prix du put au cours du temps [Splitting Euler Implicite]"</span>)</span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="edp_american_opt_files/figure-html/cell-17-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Le sch√©ma de splitting d‚ÄôEuler implicite est un sch√©ma implicite qui permet de s√©parer la partie lin√©aire de l‚ÄôEDP de la partie non lin√©aire. En appliquant ce sch√©ma, on observe, ci dessus, une √©volution du prix du put au cours du temps qui est plus stable que celle obtenue avec le sch√©ma d‚ÄôEuler explicite.</p>
<p>Bien qu‚Äôils puissent √™tre moins pr√©cis qu‚Äôun vrai sch√©ma d‚ÄôEuler implicite ‚Äúfully implicit‚Äù, les sch√©mas de splitting d‚ÄôEuler implicite et de splitting de Crank-Nicolson sont plus simples √† impl√©menter et peuvent offrir une bonne approximation du prix du put am√©ricain, tout en √©tant plus stables que le sch√©ma d‚ÄôEuler explicite. Par ailleurs, en ce qui concerne les ordres de convergence, les sch√©mas de splitting d‚ÄôEuler implicite et de splitting de Crank-Nicolson peuvent pr√©senter des ordres de convergence similaires √† ceux des sch√©mas d‚ÄôEuler implicite et de Crank-Nicolson classiques.</p>
<div id="55101c6a" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>N_grid <span class="op">=</span> J_grid <span class="op">=</span> np.array([<span class="dv">20</span><span class="op">*</span>(<span class="dv">2</span><span class="op">**</span>k) <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>)]).astype(<span class="bu">int</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Splitting scheme"</span>)</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">75</span>, <span class="st">"</span><span class="ch">\n</span><span class="st">Convergence Table for Scheme EI:"</span>)</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(get_convergence_table(N_grid, J_grid<span class="op">-</span><span class="dv">1</span>, params, Sval, SplittingScheme))</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"="</span><span class="op">*</span><span class="dv">75</span>, <span class="st">"</span><span class="ch">\n</span><span class="st">Convergence Table for Scheme CN:"</span>)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(get_convergence_table(N_grid, J_grid<span class="op">-</span><span class="dv">1</span>, params, Sval, SchemeCN))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Splitting scheme
=========================================================================== 
Convergence Table for Scheme EI:
     J    N       U(s)     error     alpha      tcpu
0   19   20  12.771151  0.000000  0.000000  0.001442
1   39   40  12.958929  0.187778  0.000000  0.001753
2   79   80  13.054834  0.095904  0.969364  0.004257
3  159  160  13.089790  0.034957  1.456030  0.010195
4  319  320  13.105599  0.015809  1.144811  0.026634
=========================================================================== 
Convergence Table for Scheme CN:
     J    N       U(s)     error     alpha      tcpu
0   19   20  12.888852  0.000000  0.000000  0.000767
1   39   40  13.021900  0.133049  0.000000  0.001050
2   79   80  13.090984  0.069084  0.945528  0.002674
3  159  160  13.107807  0.016823  2.037952  0.006654
4  319  320  13.114979  0.007172  1.229912  0.019724</code></pre>
</div>
</div>
</section>
<section id="psor-algorithm-1" class="level3">
<h3 class="anchored" data-anchor-id="psor-algorithm-1">PSOR Algorithm</h3>
<p>Comme attendu, le sch√©ma PSOR prend plus de temps √† converger que les sch√©mas d‚ÄôEuler implicite et de Crank-Nicolson, en raison de la nature it√©rative de la m√©thode PSOR. Cependant, il offre une bonne approximation du prix du put am√©ricain, tout en √©tant plus stable que le sch√©ma d‚ÄôEuler explicite.</p>
<div id="c4f81aaf" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>params[<span class="st">'J'</span>] <span class="op">=</span> <span class="dv">100</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>params[<span class="st">'N'</span>] <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Param√®tres financiers:"</span>)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"r=</span><span class="sc">%.2f</span><span class="st">"</span> <span class="op">%</span>r_, <span class="st">"sigma=</span><span class="sc">%.2f</span><span class="st">"</span> <span class="op">%</span>sigma_, <span class="st">"K=%.0f"</span> <span class="op">%</span>K_, <span class="st">"T=%.0f"</span> <span class="op">%</span>T_)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Param√®tres num√©riques:"</span>)</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"J=%.0f"</span> <span class="op">%</span>params[<span class="st">'J'</span>], <span class="st">"N=%.0f"</span> <span class="op">%</span>params[<span class="st">'N'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Param√®tres financiers:
r=0.10 sigma=0.30 K=100 T=1
Param√®tres num√©riques:
J=99 N=10</code></pre>
</div>
</div>
<div id="e9b9967b" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>psor <span class="op">=</span> PSOR(<span class="op">**</span>params, payoff<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>U,t <span class="op">=</span> psor.solve() <span class="co"># omega = 1.5 pour une convergence rapide</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> psor.s</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> psor.dt</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">5</span>))</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>plt.plot(s,U,label<span class="op">=</span><span class="st">"t=</span><span class="sc">%.2f</span><span class="st">"</span> <span class="op">%</span>(t))</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>plt.plot(s,psor.phi(s), <span class="st">'k--'</span>, label<span class="op">=</span><span class="st">"payoff"</span>)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"s"</span>)</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"u(t,s)"</span>)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Evolution du prix du put europ√©en au cours du temps [PSOR]"</span>)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="edp_american_opt_files/figure-html/cell-20-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Cependant, elle peut √™tre acc√©l√©r√©e en choisissant un param√®tre de relaxation <span class="math inline">\(\omega\)</span> appropri√©, ce qui peut r√©duire le nombre d‚Äôit√©rations n√©cessaires pour atteindre la convergence. Nous constatons que pour des valeurs de <span class="math inline">\(\omega\)</span> proches de 1.5, la m√©thode PSOR converge plus rapidement que pour des valeurs plus proches de 1, ce qui sugg√®re que l‚Äôover-relaxation peut √™tre b√©n√©fique pour acc√©l√©rer la convergence de la m√©thode PSOR.</p>
<div id="6cf089cd" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># comparing time</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>omegas <span class="op">=</span> [<span class="fl">1.2</span>, <span class="fl">1.5</span>, <span class="fl">1.8</span>, <span class="fl">1.9</span>]</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> omega <span class="kw">in</span> omegas:</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>    psor <span class="op">=</span> PSOR(<span class="op">**</span>params, payoff<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>    start_time <span class="op">=</span> time.time()</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>    U, t <span class="op">=</span> psor.solve(omega<span class="op">=</span>omega)</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>    end_time <span class="op">=</span> time.time()</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Omega: </span><span class="sc">{</span>omega<span class="sc">}</span><span class="ss">, Time taken: </span><span class="sc">{</span>end_time <span class="op">-</span> start_time<span class="sc">:.4f}</span><span class="ss"> seconds"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Omega: 1.2, Time taken: 50.6897 seconds
Omega: 1.5, Time taken: 44.9621 seconds
Omega: 1.8, Time taken: 27.1073 seconds
Omega: 1.9, Time taken: 50.4578 seconds</code></pre>
</div>
</div>
</section>
<section id="semi-smooth-newtons-method-1" class="level3">
<h3 class="anchored" data-anchor-id="semi-smooth-newtons-method-1">Semi-smooth Newton‚Äôs method</h3>
<p>En g√©n√©ral, la m√©thode PSOR est une m√©thode efficace pour r√©soudre les probl√®mes d‚Äôobstacle associ√©s aux options am√©ricaines, mais elle peut √™tre moins rapide que les m√©thodes de type Newton pour des probl√®mes de grande taille ou pour des sch√©mas d‚Äôordre sup√©rieur.</p>
<p>Pour ce faire, nous avons impl√©ment√© une m√©thode de type Newton pour r√©soudre le probl√®me d‚Äôobstacle √† chaque pas de temps. Cette m√©thode consiste √† lin√©ariser le probl√®me d‚Äôobstacle autour d‚Äôune solution approximative √† chaque it√©ration, et √† r√©soudre le probl√®me lin√©aris√© pour obtenir une nouvelle approximation.</p>
<div id="55c766e2" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>params[<span class="st">'J'</span>] <span class="op">=</span> <span class="dv">100</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>params[<span class="st">'N'</span>] <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Param√®tres financiers:"</span>)</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"r=</span><span class="sc">%.2f</span><span class="st">"</span> <span class="op">%</span>r_, <span class="st">"sigma=</span><span class="sc">%.2f</span><span class="st">"</span> <span class="op">%</span>sigma_, <span class="st">"K=%.0f"</span> <span class="op">%</span>K_, <span class="st">"T=%.0f"</span> <span class="op">%</span>T_)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Param√®tres num√©riques:"</span>)</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"J=%.0f"</span> <span class="op">%</span>params[<span class="st">'J'</span>], <span class="st">"N=%.0f"</span> <span class="op">%</span>params[<span class="st">'N'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Param√®tres financiers:
r=0.10 sigma=0.30 K=100 T=1
Param√®tres num√©riques:
J=99 N=10</code></pre>
</div>
</div>
<div id="bfc9dbda" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>newtonss <span class="op">=</span> NewtonSemiSmooth(<span class="op">**</span>params, payoff<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>U,t <span class="op">=</span> newtonss.solve()</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> newtonss.s</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> newtonss.dt</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">5</span>))</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>plt.plot(s,U,label<span class="op">=</span><span class="st">"t=</span><span class="sc">%.2f</span><span class="st">"</span> <span class="op">%</span>(t))</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>plt.plot(s,newtonss.phi(s), <span class="st">'k--'</span>, label<span class="op">=</span><span class="st">"payoff"</span>)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"s"</span>)</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"u(t,s)"</span>)</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Evolution du prix du put europ√©en au cours du temps [Newton Semi-Smooth]"</span>)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="edp_american_opt_files/figure-html/cell-23-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="mini-conclusion-sur-les-sch√©ma-implicites" class="level3">
<h3 class="anchored" data-anchor-id="mini-conclusion-sur-les-sch√©ma-implicites">Mini-conclusion sur les sch√©ma implicites</h3>
<p>L‚Äô√©tude des sch√©mas implicites et semi-implicites montre que, lorsque le maillage spatial J et le pas temporel N sont raffin√©s, toutes les m√©thodes test√©es produisent des solutions num√©riques de plus en plus pr√©cises. Les ordres de convergence estim√©s (Œ±) sont coh√©rents avec les pr√©dictions th√©oriques : proches de 1 pour Euler implicite et proches de 2 pour Crank-Nicolson.</p>
<p>Le raffinement du maillage et du pas de temps s‚Äôaccompagne d‚Äôune augmentation notable du temps de calcul, ce que mettent en √©vidence les tables de convergence et qui illustre clairement le compromis entre pr√©cision et co√ªt computationnel.</p>
<p>En termes de qualit√© des solutions, les m√©thodes num√©riques explor√©es (PSOR et Newton semi-smooth) produisent des r√©sultats lisses et coh√©rents, respectant correctement la contrainte d‚Äôobstacle.</p>
</section>
</section>
<section id="higher-order-schemes-1" class="level2">
<h2 class="anchored" data-anchor-id="higher-order-schemes-1">Higher order schemes</h2>
<p>Apr√®s avoir √©tudi√© les sch√©mas implicites classiques et les m√©thodes de r√©solution pour le probl√®me d‚Äôobstacle, nous consid√©rons √©galement un sch√©ma d‚Äôordre 2, le BDF2, qui am√©liore la pr√©cision temporelle tout en prenant en compte l‚Äôobstacle.</p>
<section id="bdf-scheme" class="level3">
<h3 class="anchored" data-anchor-id="bdf-scheme">BDF Scheme</h3>
<p>Le sch√©ma BDF2 est test√© avec les m√™mes param√®tres de maillage spatial et de pas de temps que les sch√©mas pr√©c√©dents. Le graphique ci-dessous montre que le prix du put europ√©en reste lisse et coh√©rent, respectant correctement la contrainte d‚Äôobstacle, de mani√®re similaire aux autres m√©thodes implicites √©tudi√©es.</p>
<div id="89b22ccc" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>params[<span class="st">'J'</span>] <span class="op">=</span> <span class="dv">100</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>params[<span class="st">'N'</span>] <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>bdf2 <span class="op">=</span> BdfScheme(<span class="op">**</span>params, payoff<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>U,t <span class="op">=</span> bdf2.solve()</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> bdf2.s</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> bdf2.dt</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">5</span>))</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>plt.plot(s,U,label<span class="op">=</span><span class="st">"t=</span><span class="sc">%.2f</span><span class="st">"</span> <span class="op">%</span>(t))</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>plt.plot(s,bdf2.phi(s), <span class="st">'k--'</span>, label<span class="op">=</span><span class="st">"payoff"</span>)</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">"s"</span>)</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">"u(t,s)"</span>)</span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Evolution du prix du put europ√©en au cours du temps [BDF2]"</span>)</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="edp_american_opt_files/figure-html/cell-24-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("^(?:http:|https:)\/\/cheryl-kdio\.github\.io\/custom");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
          // target, if specified
          link.setAttribute("target", "_blank");
          if (link.getAttribute("rel") === null) {
            link.setAttribute("rel", "noopener");
          }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<a href="https://github.com/cheryl-kdio">Cheryl Kouadio</a> ¬©
<script>document.write(new Date().getFullYear())</script>
</div>   
    <div class="nav-footer-center">
<a href="https://github.com/cheryl-kdio">Cheryl Kouadio</a> ¬©
<script>document.write(new Date().getFullYear())</script>
</div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/cheryl-kdio" target="_blank">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>